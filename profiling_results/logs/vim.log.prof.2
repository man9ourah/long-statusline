FUNCTION  <SNR>3_StringReplace()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:857
Called 54 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
   54              0.000316 	let l:data = split(a:text, a:old, 1)
   54              0.000123 	return join(l:data, a:new)

FUNCTION  <SNR>3_AsyncRun_Job_AutoCmd()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:446
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000005 	if !has('autocmd') | return | endif
    1              0.000004 	let name = (a:auto == '')? g:asyncrun_auto : a:auto
    1              0.000011 	if name !~ '^\w\+$' || name == 'NONE' || name == '<NONE>'
    1              0.000002 		return
                            	endif
                            	if ((g:asyncrun_skip / 4) % 2) != 0
                            		return 0
                            	endif
                            	if a:mode == 0
                            		if g:asyncrun_silent
                            			silent exec 'doautocmd QuickFixCmdPre '. name
                            		else
                            			exec 'doautocmd QuickFixCmdPre '. name
                            		endif
                            	else
                            		if g:asyncrun_silent
                            			silent exec 'doautocmd QuickFixCmdPost '. name
                            		else
                            			exec 'doautocmd QuickFixCmdPost '. name
                            		endif
                            	endif

FUNCTION  <SNR>3_AsyncRun_Job_Start()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:628
Called 1 time
Total time:   0.000901
 Self time:   0.000757

count  total (s)   self (s)
    1              0.000002 	let l:running = 0
    1              0.000002 	let l:empty = 0
    1              0.000001 	if s:asyncrun_support == 0
                            		call s:NotSupport()
                            		return -1
    1              0.000001 	endif
    1              0.000002 	if exists('s:async_job')
                            		if !has('nvim')
                            			if job_status(s:async_job) == 'run'
                            				let l:running = 1
                            			endif
                            		else
                            			if s:async_job > 0
                            				let l:running = 1
                            			endif
                            		endif
    1              0.000000 	endif
    1              0.000003 	if type(a:cmd) == 1
    1              0.000003 		if a:cmd == '' | let l:empty = 1 | endif
                            	elseif type(a:cmd) == 3
                            		if a:cmd == [] | let l:empty = 1 | endif
    1              0.000001 	endif
    1              0.000002 	if s:async_state != 0 || l:running != 0
                            		call s:ErrorMsg("background job is still running")
                            		return -2
    1              0.000001 	endif
    1              0.000001 	if l:empty != 0
                            		call s:ErrorMsg("empty arguments")
                            		return -3
    1              0.000000 	endif
    1              0.000002 	let l:args = []
    1              0.000002 	if g:asyncrun_shell == ''
    1              0.000027 		let l:args += split(&shell)
    1              0.000006 		let l:args += split(&shellcmdflag)
                            	else
                            		let l:args += split(g:asyncrun_shell)
                            		let l:args += split(g:asyncrun_shellflag)
    1              0.000000 	endif
    1              0.000003 	let s:async_info.errorformat = s:async_efm
    1              0.000002 	let l:name = []
    1              0.000002 	if type(a:cmd) == 1
    1              0.000001 		let l:name = a:cmd
    1              0.000001 		if s:asyncrun_windows == 0
    1              0.000003 			let l:args += [a:cmd]
                            		else
                            			let l:tmp = s:ScriptWrite(a:cmd, 0)
                            			if s:async_nvim == 0
                            				let l:args += [l:tmp]
                            			else
                            				let l:args = s:shellescape(l:tmp)
                            			endif
    1              0.000000 		endif
                            	elseif type(a:cmd) == 3
                            		if s:asyncrun_windows == 0
                            			let l:temp = []
                            			for l:item in a:cmd
                            				if index(['|', '`'], l:item) < 0
                            					let l:temp += [fnameescape(l:item)]
                            				else
                            					let l:temp += ['|']
                            				endif
                            			endfor
                            			let l:args += [join(l:temp, ' ')]
                            		else
                            			let l:args += a:cmd
                            		endif
                            		let l:vector = []
                            		for l:x in a:cmd
                            			let l:vector += ['"'.l:x.'"']
                            		endfor
                            		let l:name = join(l:vector, ', ')
    1              0.000001 	endif
    1              0.000002 	let s:async_state = 0
    1              0.000002 	let s:async_output = {}
    1              0.000001 	let s:async_head = 0
    1              0.000001 	let s:async_tail = 0
    1              0.000002 	let s:async_info.post = s:async_info.postsave
    1              0.000002 	let s:async_info.auto = s:async_info.autosave
    1              0.000001 	let s:async_info.postsave = ''
    1              0.000002 	let s:async_info.autosave = ''
    1              0.000002 	let g:asyncrun_text = s:async_info.text
    1   0.000047   0.000010 	call s:AutoCmd('Pre')
    1              0.000001 	if s:async_nvim == 0
    1              0.000003 		let l:options = {}
    1              0.000007 		let l:options['callback'] = function('s:AsyncRun_Job_OnCallback')
    1              0.000005 		let l:options['close_cb'] = function('s:AsyncRun_Job_OnClose')
    1              0.000004 		let l:options['exit_cb'] = function('s:AsyncRun_Job_OnExit')
    1              0.000001 		let l:options['out_io'] = 'pipe'
    1              0.000001 		let l:options['err_io'] = 'out'
    1              0.000002 		let l:options['in_io'] = 'null'
    1              0.000002 		let l:options['out_mode'] = 'nl'
    1              0.000001 		let l:options['err_mode'] = 'nl'
    1              0.000002 		let l:options['stoponexit'] = 'term'
    1              0.000002 		if g:asyncrun_stop != ''
                            			let l:options['stoponexit'] = g:asyncrun_stop
    1              0.000001 		endif
    1              0.000002 		if s:async_info.range > 0
                            			let l:options['in_io'] = 'buffer'
                            			let l:options['in_mode'] = 'nl'
                            			let l:options['in_buf'] = s:async_info.range_buf
                            			let l:options['in_top'] = s:async_info.range_top
                            			let l:options['in_bot'] = s:async_info.range_bot
    1              0.000004 		elseif exists('*ch_close_in')
    1              0.000001 			if g:asyncrun_stdin != 0
                            				let l:options['in_io'] = 'pipe'
    1              0.000001 			endif
    1              0.000001 		endif
    1              0.000311 		let s:async_job = job_start(l:args, l:options)
    1              0.000008 		let l:success = (job_status(s:async_job) != 'fail')? 1 : 0
    1              0.000003 		if l:success && l:options['in_io'] == 'pipe'
                            			silent! call ch_close_in(job_getchannel(s:async_job))
    1              0.000001 		endif
                            	else
                            		let l:callbacks = {'shell': 'AsyncRun'}
                            		let l:callbacks['on_stdout'] = function('s:AsyncRun_Job_NeoVim')
                            		let l:callbacks['on_stderr'] = function('s:AsyncRun_Job_NeoVim')
                            		let l:callbacks['on_exit'] = function('s:AsyncRun_Job_NeoVim')
                            		let s:neovim_stdout = ''
                            		let s:neovim_stderr = ''
                            		let s:async_job = jobstart(l:args, l:callbacks)
                            		let l:success = (s:async_job > 0)? 1 : 0
                            		if l:success != 0
                            			if s:async_info.range > 0
                            				let l:top = s:async_info.range_top
                            				let l:bot = s:async_info.range_bot
                            				let l:lines = getline(l:top, l:bot)
                            				if exists('*chansend')
                            					call chansend(s:async_job, l:lines)
                            				elseif exists('*jobsend')
                            					call jobsend(s:async_job, l:lines)
                            				endif
                            			endif
                            			if exists('*chanclose')
                            				call chanclose(s:async_job, 'stdin')
                            			elseif exists('*jobclose')
                            				call jobclose(s:async_job, 'stdin')
                            			endif
                            		endif
    1              0.000004 	endif
    1              0.000001 	if l:success != 0
    1              0.000004 		let s:async_state = or(s:async_state, 1)
    1              0.000002 		let g:asyncrun_status = "running"
    1              0.000002 		let s:async_start = localtime()
    1              0.000006 		let l:arguments = "[".l:name."]"
    1              0.000003 		let l:title = ':AsyncRun '.l:name
    1              0.000002 		if !s:async_info.append
    1              0.000001 			if s:async_nvim == 0
    1              0.000003 				if v:version >= 800 || has('patch-7.4.2210')
    1              0.000023 					call setqflist([], ' ', {'title':l:title})
                            				else
                            					call setqflist([], ' ')
    1              0.000001 				endif
                            			else
                            				call setqflist([], ' ', l:title)
    1              0.000001 			endif
    1              0.000001 		endif
    1              0.000001 		if !s:async_info.strip
    1              0.000014 			call setqflist([{'text':l:arguments}], 'a')
    1              0.000001 		endif
    1              0.000002 		let l:name = 'g:AsyncRun_Job_OnTimer'
    1              0.000009 		let s:async_timer = timer_start(100, l:name, {'repeat':-1})
    1   0.000084   0.000060 		call s:AsyncRun_Job_AutoCmd(0, s:async_info.auto)
    1   0.000103   0.000020 		call s:AutoCmd('Start')
    1              0.000001 		redrawstatus!
                            	else
                            		unlet s:async_job
                            		call s:ErrorMsg("Background job start failed '".a:cmd."'")
                            		redrawstatus!
                            		return -5
    1              0.000001 	endif
    1              0.000003 	return 0

FUNCTION  <SNR>3_find_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1008
Called 1 time
Total time:   0.000912
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000007 	function! s:guess_root(filename, markers)
                            		let fullname = asyncrun#fullname(a:filename)
                            		if fullname =~ '^fugitive:/'
                            			if exists('b:git_dir')
                            				return fnamemodify(b:git_dir, ':h')
                            			endif
                            			return '' " skip any fugitive buffers early
                            		endif
                            		let pivot = fullname
                            		if !isdirectory(pivot)
                            			let pivot = fnamemodify(pivot, ':h')
                            		endif
                            		while 1
                            			let prev = pivot
                            			for marker in a:markers
                            				let newname = s:path_join(pivot, marker)
                            				if newname =~ '[\*\?\[\]]'
                            					if glob(newname) != ''
                            						return pivot
                            					endif
                            				elseif filereadable(newname)
                            					return pivot
                            				elseif isdirectory(newname)
                            					return pivot
                            				endif
                            			endfor
                            			let pivot = fnamemodify(pivot, ':h')
                            			if pivot == prev
                            				break
                            			endif
                            		endwhile
                                    return ''
                            	endfunc
    1              0.000002 	if a:path == '%'
    1              0.000004 		if exists('b:asyncrun_root') && b:asyncrun_root != ''
                            			return b:asyncrun_root
    1              0.000004 		elseif exists('t:asyncrun_root') && t:asyncrun_root != ''
                            			return t:asyncrun_root
    1              0.000003 		elseif exists('g:asyncrun_root') && g:asyncrun_root != ''
                            			return g:asyncrun_root
    1              0.000001 		endif
    1              0.000001 	endif
    1   0.000802   0.000013 	let root = s:guess_root(a:path, a:markers)
    1              0.000002 	if root != ''
    1   0.000060   0.000007 		return asyncrun#fullname(root)
                            	elseif a:strict != 0
                            		return ''
                            	endif
                            	" Not found: return parent directory of current file / file itself.
                            	let fullname = asyncrun#fullname(a:path)
                            	if isdirectory(fullname)
                            		return fullname
                            	endif
                            	return asyncrun#fullname(fnamemodify(fullname, ':h'))

FUNCTION  <SNR>5_GitInit()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:311
Called 300 times
Total time:   0.017001
 Self time:   0.012224

count  total (s)   self (s)
                            
  300              0.000969     if !has_key(s:GitStatus, a:buf)
    1              0.000015         let s:GitStatus[a:buf] = {"LocalEnable" : 1 ,"IsGit": 0, "RootDir": "", "BranchName": "",  "Dirty": "", "IsTracked": 0, "InsertNum": 0, "DeleteNum": 0, "CacheExpired": 0}
  300              0.000198     endif
                            
  300              0.000897     if !s:GitStatus["enabled"] || !s:GitStatus[a:buf]["LocalEnable"]
                                    return
  300              0.000126     endif
                            
  300              0.002875     let l:flname = expand("#" . a:buf . ":p")
                                " If we opened a dir or taglist, ignore.
  300              0.002399     if !filereadable(l:flname)
                                    let s:GitStatus[a:buf]["LocalEnable"] = 0
                                    return
  300              0.000151     endif 
                            
  300              0.000723     if s:GitStatus[a:buf]["CacheExpired"] > 0
                                    " Dont update unless it has been a while
  299              0.000802         let s:GitStatus[a:buf]["CacheExpired"] -= 1
  299              0.000237         return
    1              0.000001     endif
                            
                                " Renew Cache after update
    1              0.000005     let s:GitStatus[a:buf]["CacheExpired"] = s:GitMaxCacheExp
                            
    1   0.004791   0.000014     call s:GitUpdate(1, a:buf)
                            

FUNCTION  <SNR>3_check_quickfix()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:2003
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004 		let height = get(g:, "asyncrun_open", 0)
    1              0.000003 		if exists('s:asyncrun_open')
                            			let height = s:asyncrun_open
    1              0.000001 		endif
                            		" echo 'height: '.height . ' ' .s:asyncrun_open
    1              0.000001 		if height > 0
                            			call asyncrun#quickfix_toggle(height, 1)
    1              0.000000 		endif

FUNCTION  <SNR>3_StringStrip()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:863
Called 2 times
Total time:   0.000339
 Self time:   0.000339

count  total (s)   self (s)
    2              0.000338 	return substitute(a:text, '^\s*\(.\{-}\)\s*$', '\1', '')

FUNCTION  <SNR>3_guess_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1009
Called 1 time
Total time:   0.000789
 Self time:   0.000338

count  total (s)   self (s)
    1   0.000087   0.000011 		let fullname = asyncrun#fullname(a:filename)
    1              0.000005 		if fullname =~ '^fugitive:/'
                            			if exists('b:git_dir')
                            				return fnamemodify(b:git_dir, ':h')
                            			endif
                            			return '' " skip any fugitive buffers early
    1              0.000001 		endif
    1              0.000002 		let pivot = fullname
    1              0.000005 		if !isdirectory(pivot)
    1              0.000004 			let pivot = fnamemodify(pivot, ':h')
    1              0.000000 		endif
    2              0.000002 		while 1
    2              0.000004 			let prev = pivot
    8              0.000013 			for marker in a:markers
    7   0.000431   0.000056 				let newname = s:path_join(pivot, marker)
    7              0.000072 				if newname =~ '[\*\?\[\]]'
                            					if glob(newname) != ''
                            						return pivot
                            					endif
    7              0.000050 				elseif filereadable(newname)
                            					return pivot
    7              0.000026 				elseif isdirectory(newname)
    1              0.000001 					return pivot
    6              0.000003 				endif
    7              0.000006 			endfor
    1              0.000004 			let pivot = fnamemodify(pivot, ':h')
    1              0.000002 			if pivot == prev
                            				break
    1              0.000001 			endif
    1              0.000001 		endwhile
                                    return ''

FUNCTION  <SNR>3_path_join()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:975
Called 7 times
Total time:   0.000375
 Self time:   0.000375

count  total (s)   self (s)
    7              0.000020     let l:size = strlen(a:home)
    7              0.000027     if l:size == 0 | return a:name | endif
    7              0.000026     let l:last = strpart(a:home, l:size - 1, 1)
    7              0.000064     if has("win32") || has("win64") || has("win16") || has('win95')
                            		let l:first = strpart(a:name, 0, 1)
                            		if l:first == "/" || l:first == "\\"
                            			let head = strpart(a:home, 1, 2)
                            			if index([":\\", ":/"], head) >= 0
                            				return strpart(a:home, 0, 2) . a:name
                            			endif
                            			return a:name
                            		elseif index([":\\", ":/"], strpart(a:name, 1, 2)) >= 0
                            			return a:name
                            		endif
                                    if l:last == "/" || l:last == "\\"
                                        return a:home . a:name
                                    else
                                        return a:home . '/' . a:name
                                    endif
    7              0.000006     else
    7              0.000018 		if strpart(a:name, 0, 1) == "/"
                            			return a:name
    7              0.000004 		endif
    7              0.000009         if l:last == "/"
                                        return a:home . a:name
    7              0.000005         else
    7              0.000018             return a:home . '/' . a:name
                                    endif
                                endif

FUNCTION  <SNR>5_GitUpdate()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:273
Called 1 time
Total time:   0.004777
 Self time:   0.000198

count  total (s)   self (s)
    1              0.000005     let l:buf = get(a:, 1, bufnr())
                            
    1              0.000004     if !s:GitStatus["enabled"] || !s:GitStatus[l:buf]["LocalEnable"]
                                    return
    1              0.000000     endif
                                
    1              0.000014     let l:flname = expand("#" . l:buf . ":p")
    1              0.000005     let l:parentDir = fnamemodify(l:flname, ":h")
    1              0.000086     let l:tmpfile = tempname()
    1              0.000004     let l:redir = l:tmpfile ." 2> /dev/null "
    1              0.000004     let l:isFullUpdate = a:initOrWrite || !s:GitStatus[l:buf]["IsGit"]
    1              0.000002     let l:cmd = ""
                            
    1              0.000002     if l:isFullUpdate
    1              0.000005         let l:cmd  = "git -C " . l:parentDir . " rev-parse --absolute-git-dir > " . l:redir . "&& "
    1              0.000004         let l:cmd .= "(git -C " . l:parentDir . " symbolic-ref HEAD || " 
    1              0.000005         let l:cmd .= "git -C " . l:parentDir . " rev-parse --short HEAD) >> " . l:redir . "&& "
    1              0.000001     endif
                            
    1              0.000007     let l:cmd .= "([[ -n $(git -C " . l:parentDir . " ls-files " . l:flname . ") ]] && " .  "echo '1'  || echo '0') >> " . l:redir . "&& "
    1              0.000004     let l:cmd .= "([[ -z $(git -C " . l:parentDir . " status -s) ]] || echo '*') >> " . l:redir . "&& "
    1              0.000005     let l:cmd .= "git -C " . l:parentDir . " diff --numstat -- " . l:flname . " >> " . l:redir
                                
    1              0.000003     if g:asyncrun_status != "running"
                                    " Async call to g:AsyncGitCallback()
    1   0.004602   0.000023         call asyncrun#run("",  {"post": "call g:AsyncGitCallback(" . l:isFullUpdate . ", '" . l:tmpfile . "', " .  l:buf . ")"}, l:cmd)
                                else
                                    " If we could not execute it now, void the cache so that it is executed
                                    " the next time 
                                    let s:GitStatus[l:buf]["CacheExpired"] = 0
    1              0.000001     endif

FUNCTION  SetStatusLine()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:138
Called 300 times
Total time:   0.054308
 Self time:   0.013854

count  total (s)   self (s)
  300              0.001177     let l:winnum = win_id2win(a:winid)
  300              0.000672     let l:buf = winbufnr(l:winnum)
  300              0.000775     let l:isActiveWindow = (l:winnum == winnr())
                                
                                " Initialize Git
  300   0.018910   0.001909     call s:GitInit(l:buf)
                            
                                " Mode
  300              0.001330     let l:sts = s:modeMap[l:isActiveWindow][a:nextToTaglist][mode()]
                            
                                " File or function name
  300   0.016404   0.002409     let l:sts .= s:BuildFilenameLbl(l:buf, l:isActiveWindow)
                             
                                " Left align
  300              0.000435     let l:sts .= "%="
                                
                            
                                " Modified flag
  300              0.001488     let l:sts .= s:modifiedFlag[getbufvar(l:buf, "&modified")][l:isActiveWindow]
                              
                                " Information bar
  300   0.011428   0.001970     let l:sts .= s:BuildInfBar(l:buf, l:isActiveWindow)
                            
  300              0.000287     return l:sts

FUNCTION  <SNR>5_ManageWinStl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:178
Called 201 times
Total time:   0.023384
 Self time:   0.023384

count  total (s)   self (s)
  201              0.000773     let l:bottomRightWin = winnr('$')
                            
  502              0.001036     for n in range(1, bottomRightWin)
  301              0.000674         let l:wintype = win_gettype(n)
                            
                                    " Ignore popup & autocmd
  301              0.000594         if (l:wintype !=# 'popup' || l:wintype !=# 'autocmd')
  301              0.000582             let l:bufnum = winbufnr(n)
  301              0.000750             let l:winbufname = bufname(l:bufnum)
  301              0.000596             let l:winid = win_getid(n)
  301              0.001272             let l:isPrv = getwinvar(n, "&pvw")
  301              0.002843             let l:isHelp = getbufvar(l:winbufname, "&ft") ==# "help"
  301              0.000915             let l:isQf = getwinvar(n, '&syntax') == 'qf'
                            
  301              0.000490             if l:winbufname ==# g:TagList_title
                                            " Set the taglist status line
                                            call setwinvar(n, '&statusline', "%!SetTaglistSts()")
                            
  301              0.000741             elseif l:isPrv || l:isHelp || l:isQf || l:wintype ==# "command"
                                            " Set straight line
                                            call setwinvar(n, '&statusline',  "%#StraightLine#%{" .  "repeat('━',\ winwidth(win_id2win(".l:winid.")))" .  "}")
                            
  301              0.001251             elseif (n == l:bottomRightWin) &&  ((winwidth(n) + winwidth(1) + 1 ) == &columns)
                            
                                            " Only two windows in the bottom
  100              0.000424                 call setwinvar(n, '&statusline', "%!SetStatusLine(".l:winid.", 1)")
                            
  201              0.000122             else
                                            " Other windows status lines
  201              0.001138                 call setwinvar(n, '&statusline', "%!SetStatusLine(".l:winid.", 0)")
  301              0.000193             end
                            
  301              0.000198         endif
                            
  502              0.000500     endfor

FUNCTION  asyncrun#run()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1689
Called 1 time
Total time:   0.004579
 Self time:   0.001239

count  total (s)   self (s)
    1              0.000002 	let l:macros = {}
    1              0.000015 	let l:macros['VIM_FILEPATH'] = expand("%:p")
    1              0.000004 	let l:macros['VIM_FILENAME'] = expand("%:t")
    1              0.000008 	let l:macros['VIM_FILEDIR'] = expand("%:p:h")
    1              0.000003 	let l:macros['VIM_FILENOEXT'] = expand("%:t:r")
    1              0.000006 	let l:macros['VIM_PATHNOEXT'] = expand("%:p:r")
    1              0.000004 	let l:macros['VIM_FILEEXT'] = "." . expand("%:e")
    1              0.000003 	let l:macros['VIM_FILETYPE'] = (&filetype)
    1              0.000005 	let l:macros['VIM_CWD'] = getcwd()
    1              0.000003 	let l:macros['VIM_RELDIR'] = expand("%:h:.")
    1              0.000008 	let l:macros['VIM_RELNAME'] = expand("%:p:.")
    1              0.000006 	let l:macros['VIM_CWORD'] = expand("<cword>")
    1              0.000004 	let l:macros['VIM_CFILE'] = expand("<cfile>")
    1              0.000003 	let l:macros['VIM_CLINE'] = line('.')
    1              0.000003 	let l:macros['VIM_VERSION'] = ''.v:version
    1              0.000003 	let l:macros['VIM_SVRNAME'] = v:servername
    1              0.000003 	let l:macros['VIM_COLUMNS'] = ''.&columns
    1              0.000003 	let l:macros['VIM_LINES'] = ''.&lines
    1              0.000008 	let l:macros['VIM_GUI'] = has('gui_running')? 1 : 0
    1   0.000966   0.000013 	let l:macros['VIM_ROOT'] = asyncrun#get_root('%')
    1              0.000023     let l:macros['VIM_HOME'] = expand(split(&rtp, ',')[0])
    1              0.000006 	let l:macros['VIM_PRONAME'] = fnamemodify(l:macros['VIM_ROOT'], ':t')
    1              0.000005 	let l:macros['VIM_DIRNAME'] = fnamemodify(l:macros['VIM_CWD'], ':t')
    1              0.000002 	let l:macros['VIM_PWD'] = l:macros['VIM_CWD']
    1              0.000003 	let l:macros['<cwd>'] = l:macros['VIM_CWD']
    1              0.000003 	let l:macros['<root>'] = l:macros['VIM_ROOT']
    1              0.000002 	let l:macros['<pwd>'] = l:macros['VIM_PWD']
    1              0.000002 	let l:retval = ''
                            
                            	" handle: empty extension
    1              0.000004 	if expand("%:e") == ''
                            		let l:macros['VIM_FILEEXT'] = ''
    1              0.000001 	endif
                            
                            	" extract options
    1   0.000479   0.000031 	let [l:command, l:opts] = s:ExtractOpt(s:StringStrip(a:args))
                            
                            	" check lazy load
    1              0.000003 	if get(l:opts, 'mode', '') == 'load'
                            		return ''
    1              0.000001 	endif
                            
                            	" combine options
    1              0.000004 	if type(a:opts) == type({})
    2              0.000007 		for [l:key, l:val] in items(a:opts)
    1              0.000003 			let l:opts[l:key] = l:val
    2              0.000003 		endfor
    1              0.000001 	endif
                            
                            	" parse makeprg/grepprg and return
    1              0.000002 	if l:opts.program == 'parse'
                            		let s:async_program_cmd = l:command
                            		return s:async_program_cmd
    1              0.000001 	endif
                            
                            	" update marcros
    1              0.000004 	let l:macros['VIM_RUNNAME'] = get(l:opts, 'name', '')
                            
                            	" update info (current running command text)
    1              0.000003 	let g:asyncrun_info = a:args
                            
                            	" setup range
    1              0.000002 	let l:opts.range = 0
    1              0.000001 	let l:opts.range_top = 0
    1              0.000001 	let l:opts.range_bot = 0
    1              0.000002 	let l:opts.range_buf = 0
                            
    1              0.000002 	if a:0 >= 3
                            		if a:1 > 0 && a:2 <= a:3
                            			let l:opts.range = 2
                            			let l:opts.range_top = a:2
                            			let l:opts.range_bot = a:3
                            			let l:opts.range_buf = bufnr('%')
                            		endif
    1              0.000001 	endif
                            
                            	" check cwd
    1              0.000002 	if l:opts.cwd != ''
                            		for [l:key, l:val] in items(l:macros)
                            			let l:replace = (l:key[0] != '<')? '$('.l:key.')' : l:key
                            			let l:opts.cwd = s:StringReplace(l:opts.cwd, l:replace, l:val)
                            		endfor
                            		let l:opts.savecwd = getcwd()
                            		silent! call s:chdir(l:opts.cwd)
                            		let l:macros['VIM_CWD'] = getcwd()
                            		let l:macros['VIM_RELDIR'] = expand("%:h:.")
                            		let l:macros['VIM_RELNAME'] = expand("%:p:.")
                            		let l:macros['VIM_CFILE'] = expand("<cfile>")
                            		let l:macros['VIM_DIRNAME'] = fnamemodify(l:macros['VIM_CWD'], ':t')
                            		let l:macros['<cwd>'] = l:macros['VIM_CWD']
    1              0.000000 	endif
                            
                            	" windows can use $(WSL_XXX)
    1              0.000002 	if s:asyncrun_windows != 0
                            		let wslnames = ['FILEPATH', 'FILENAME', 'FILEDIR', 'FILENOEXT']
                            		let wslnames += ['PATHNOEXT', 'FILEEXT', 'FILETYPE', 'RELDIR']
                            		let wslnames += ['RELNAME', 'CFILE', 'ROOT', 'HOME', 'CWD']
                            		for name in wslnames
                            			let src = l:macros['VIM_' . name]
                            			let l:macros['WSL_' . name] = asyncrun#path_win2unix(src, '/mnt')
                            		endfor
    1              0.000001 	endif
                            
                            	" replace macros and setup environment variables
   28              0.000050 	for [l:key, l:val] in items(l:macros)
   27              0.000091 		let l:replace = (l:key[0] != '<')? '$('.l:key.')' : l:key
   27              0.000044 		if l:key[0] != '<'
   24              0.000049 			if strpart(l:key, 0, 4) != 'WSL_'
   24              0.000137 				exec 'let $'.l:key.' = l:val'
   24              0.000015 			endif
   27              0.000017 		endif
   27   0.000481   0.000202 		let l:command = s:StringReplace(l:command, l:replace, l:val)
   27   0.000377   0.000204 		let l:opts.text = s:StringReplace(l:opts.text, l:replace, l:val)
   28              0.000020 	endfor
                            
                            	" config
    1              0.000005 	let l:opts.cmd = l:command
    1              0.000002 	let l:opts.macros = l:macros
    1              0.000004 	let l:opts.mode = get(l:opts, 'mode', g:asyncrun_mode)
    1              0.000005 	let l:opts.errorformat = get(l:opts, 'errorformat', &errorformat)
    1              0.000003 	let s:async_scroll = (a:bang == '!')? 0 : 1
                            
                            	" check if need to save
    1              0.000002 	let l:save = get(l:opts, 'save', '')
                            
    1              0.000002 	if l:save == ''
    1              0.000002 		let l:save = ''. g:asyncrun_save
    1              0.000001 	endif
                            
    1              0.000002 	if l:save == '1'
                            		silent! update
    1              0.000001 	elseif l:save
                            		silent! wall
    1              0.000000 	endif
                            
                            	" run command
    1   0.001508   0.000021 	let l:retval = s:run(l:opts)
                            
                            	" restore cwd
    1              0.000002 	if l:opts.cwd != ''
                            		silent! call s:chdir(l:opts.savecwd)
    1              0.000001 	endif
                            
    1              0.000003 	return l:retval

FUNCTION  MeasureTime()
    Defined: ~/.vim/bundle/long-statusline/plugin/vimrc.test:8
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
  101              0.000327     for l:i in range(a:iter)
  100   0.022659   0.007183       vsplit
  100              0.157153       redraw
  100   0.018029   0.007152       quit
  100              0.096627       redraw
  101              0.000172     endfor
                                qa

FUNCTION  <SNR>5_BuildInfBar()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:105
Called 300 times
Total time:   0.009458
 Self time:   0.009458

count  total (s)   self (s)
  300              0.000709     let l:infBHighlight = (a:isActiveWindow)? "InfB" : "DisInfB"
  300              0.000831     let l:infBar = s:lASym . "%#" . l:infBHighlight . "# "
                            
  300              0.000550     if s:GitStatus[a:buf]["IsGit"]
                                    let l:infBar .= s:gitBranchSym . " " .  s:GitStatus[a:buf]["BranchName"] . s:GitStatus[a:buf]["Dirty"]
                            
                                    let l:infBar .= "%#" . l:infBHighlight . "Strick#" .  s:sepASym . "  %#" . l:infBHighlight . "#"
                                    
                                    if s:GitStatus[a:buf]["IsTracked"]
                                        let l:infBar .= s:gitInsSym . " " . s:GitStatus[a:buf]["InsertNum"] . " "
                                        let l:infBar .= s:gitDelSym . " " . s:GitStatus[a:buf]["DeleteNum"]
                                    else
                                        let l:infBar .= s:gitUnTckSym
                                    endif
                                    let l:infBar .= "%#" . l:infBHighlight . "Strick#" .  s:sepASym . "  %#" . l:infBHighlight . "#"
                            
  300              0.000152     endif
                              
  300              0.001323     let l:infBar .= s:cnumSym . " %c" . "%#" . l:infBHighlight .  "Strick#" . s:sepASym . "  %#" . l:infBHighlight . "#"
                            
  300              0.000518     let l:infBar .= s:lnumSym . " %l"
  300              0.000938     let l:infBar .= " %#RCSep" . l:infBHighlight . "#" .  s:sepBSym . "  %#RC#%2P "
                            
  300              0.000343     return l:infBar

FUNCTION  <SNR>5_BuildFilenameLbl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:79
Called 300 times
Total time:   0.013995
 Self time:   0.009258

count  total (s)   self (s)
  300              0.001524     let l:bufreadonly = getbufvar(a:buf, "&readonly") ||  (getbufvar(a:buf, "&modifiable") == 0)
                            
  300   0.007258   0.002521     let l:middleText = "%#FlnLbl#" . s:GetFilename(a:buf)  . " " .  ((l:bufreadonly) ? s:readonlySym . " " : "")
                            
  300              0.000524     let l:md = mode()
  300              0.000634     if (l:md ==? "i" || l:md ==# "R") && (a:isActiveWindow)
                                    " Consult Taglist about nearby tag
                                    let l:funcProto = Tlist_Get_Tag_Prototype_By_Line()
                            
                                    if (len(l:funcProto))
                                        " Show function name instead in insert or replace mode
                                        let l:middleText = "%#FuncLbl#" . s:tagNameSym .  " " . s:RightTruncate(l:funcProto,  (winwidth(0) - ((s:GitStatus[a:buf]["IsGit"]) ? 69 : 45)))
                            
                                    endif
                            
  300              0.000142     endif
                            
  300              0.000573     return " %<%(" . l:middleText . "%)"

FUNCTION  asyncrun#fullname()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:942
Called 2 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000005 	let f = a:f
    2              0.000008 	if f =~ "'."
                            		try
                            			redir => m
                            			silent exe ':marks' f[1]
                            			redir END
                            			let f = split(split(m, '\n')[-1])[-1]
                            			let f = filereadable(f)? f : ''
                            		catch
                            			let f = '%'
                            		endtry
    2              0.000001 	endif
    2              0.000002 	if f == '%'
    1              0.000005 		let f = expand('%')
    1              0.000006 		if &bt == 'terminal'
                            			let f = ''
    1              0.000001 		endif
    2              0.000001 	endif
    2              0.000019 	let f = fnamemodify(f, ':p')
    2              0.000005 	if s:asyncrun_windows
                            		let f = substitute(f, "\\", '/', 'g')
    2              0.000002 	endif
    2              0.000004 	if len(f) > 1
    2              0.000005 		let size = len(f)
    2              0.000007 		if f[size - 1] == '/'
    1              0.000003 			let f = strpart(f, 0, size - 1)
    2              0.000002 		endif
    2              0.000001 	endif
    2              0.000002 	return f

FUNCTION  <SNR>5_GetFilename()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:66
Called 300 times
Total time:   0.004737
 Self time:   0.004737

count  total (s)   self (s)
  300              0.002195     let l:flname = expand("#" . a:buf . ":p")
                                
  300              0.000603     if s:GitStatus[a:buf]["IsGit"]
                                    return fnamemodify(s:GitStatus[a:buf]["RootDir"], ":t") .  substitute(l:flname, s:GitStatus[a:buf]["RootDir"], "", "")
  300              0.000178     endif
                            
  300              0.000394     return l:flname

FUNCTION  <SNR>4_restore_cpo()
    Defined: ~/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim:22
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000017   let &cpo = s:save_cpo
    1              0.000004   unlet s:save_cpo

FUNCTION  <SNR>3_run()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1363
Called 1 time
Total time:   0.001487
 Self time:   0.000433

count  total (s)   self (s)
    1              0.000015 	let l:opts = deepcopy(a:opts)
    1              0.000002 	let l:command = a:opts.cmd
    1              0.000001 	let l:retval = ''
    1              0.000002 	let l:mode = g:asyncrun_mode
    1              0.000001 	let l:runner = ''
    1              0.000002 	let l:opts.origin = l:opts.cmd
                            
    1              0.000001 	if a:opts.mode != ''
                            		let l:mode = a:opts.mode
    1              0.000000 	endif
                            
                            	" mode alias
    1              0.000007 	let l:modemap = {'async':0, 'make':1, 'bang':2, 'python':3, 'os':4, 'hide':5, 'terminal': 6, 'execute':1, 'term':6, 'system':4}
                            
    1              0.000003 	let l:modemap['external'] = 4
    1              0.000001 	let l:modemap['quickfix'] = 0
    1              0.000002 	let l:modemap['vim'] = 2
                            
    1              0.000003 	let l:mode = get(l:modemap, l:mode, l:mode)
                            
                            	" alias "-mode=raw" to "-mode=async -raw=1"
    1              0.000003 	if type(l:mode) == type('') && l:mode == 'raw'
                            		let l:mode = 0
                            		let l:opts.raw = 1
    1              0.000003 	elseif type(l:mode) == 0 && l:mode == 6
                            		let pos = get(l:opts, 'pos', '')
                            		if has_key(g:asyncrun_runner, pos)
                            			let l:runner = pos
                            		elseif pos == 'bang' || pos == 'vim'
                            			let l:mode = 2
                            		elseif pos == 'extern' || pos == 'external'
                            			let l:mode = 4
                            		elseif pos == 'system' || pos == 'os'
                            			let l:mode = 4
                            		elseif pos == 'quickfix'
                            			let l:mode = 0
                            			let l:opts.raw = 1
                            		endif
    1              0.000001 	endif
                            
                            	" process makeprg/grepprg in -program=?
    1              0.000002 	let l:program = ""
                            
    1              0.000002 	let s:async_efm = a:opts.errorformat
                            
    1              0.000001 	if l:opts.program == 'make'
                            		let l:program = &makeprg
    1              0.000002 	elseif l:opts.program == 'grep'
                            		let l:program = &grepprg
                            		let s:async_efm = &grepformat
    1              0.000002 	elseif l:opts.program == 'wsl'
                            		if s:asyncrun_windows != 0
                            			let root = ($SystemRoot == '')? 'C:/Windows' : $SystemRoot
                            			let t1 = root . '/system32/wsl.exe'
                            			let t2 = root . '/sysnative/wsl.exe'
                            			let tt = executable(t1)? t1 : (executable(t2)? t2 : '')
                            			if tt == ''
                            				call s:ErrorMsg("not find wsl in your system")
                            				return
                            			endif
                            			let cmd = s:shellescape(substitute(tt, '\\', '\/', 'g'))
                            			let dist = get(l:opts, 'dist', get(g:, 'asyncrun_dist', ''))
                            			if dist != ''
                            				let cmd = cmd . ' -d ' . dist
                            			endif
                            			let l:command = cmd . ' ' . l:command
                            		else
                            			call s:ErrorMsg("only available for Windows")
                            			return ''
                            		endif
    1              0.000001 	elseif l:opts.program != ''
                            		let name = l:opts.program
                            		let test = ['cygwin', 'msys', 'mingw32', 'mingw64']
                            		if index(test, name) >= 0
                            			unsilent let l:command = s:program_msys(l:opts)
                            		else
                            			if has_key(g:asyncrun_program, name) == 0
                            				call s:ErrorMsg(name . " not found in g:asyncrun_program")
                            				return ''
                            			endif
                            			let F = g:asyncrun_program[name]
                            			if type(F) == type('')
                            				let F = function(F)
                            			endif
                            			unsilent let l:command = F(l:opts)
                            		endif
                            		if l:command == ''
                            			return ''
                            		endif
                            		let l:opts.cmd = l:command
    1              0.000000 	endif
                            
    1              0.000001 	if l:program != ''
                            		if l:program =~# '\$\*'
                            			let l:command = s:StringReplace(l:program, '\$\*', l:command)
                            		elseif l:command != ''
                            			let l:command = l:program . ' ' . l:command
                            		else
                            			let l:command = l:program
                            		endif
                            		let l:command = s:StringStrip(l:command)
                            		let s:async_program_cmd = ''
                            		silent exec 'AsyncRun -program=parse @ '. l:command
                            		let l:command = s:async_program_cmd
    1              0.000001 	endif
                            
    1              0.000013 	if l:command =~ '^\s*$'
                            		echohl ErrorMsg
                            		echom "E471: Command required"
                            		echohl NONE
                            		return
    1              0.000001 	endif
                            
    1              0.000003 	let l:wrapper = get(g:, 'asyncrun_wrapper', '')
                            
    1              0.000001 	if l:wrapper != ''
                            		let l:command = l:wrapper . ' ' . l:command
    1              0.000001 	endif
                            
    1              0.000001 	if l:mode >= 10
                            		let l:opts.cmd = l:command
                            		if g:asyncrun_hook != ''
                            			exec 'call '. g:asyncrun_hook .'(l:opts)'
                            		endif
                            		return ''
    1              0.000001 	elseif l:mode == 7
                            		if s:asyncrun_windows != 0 && s:asyncrun_gui != 0
                            			let l:mode = 4
                            		else
                            			let script = get(g:, 'asyncrun_script', '')
                            			let l:mode = (script == '')? 2 : 4
                            		endif
    1              0.000001 	endif
                            
    1              0.000002 	let g:asyncrun_cmd = l:command
    1   0.000161   0.000008 	let t = s:StringStrip(l:command)
                            
    1              0.000003 	if strpart(t, 0, 1) == ':' && g:asyncrun_strict == 0
                            		exec strpart(t, 1)
                            		return ''
    1              0.000002 	elseif l:runner != ''
                            		let F = g:asyncrun_runner[l:runner]
                            		if type(F) == type('')
                            			let F = function(F)
                            		endif
                            		let obj = deepcopy(l:opts)
                            		let obj.cmd = command
                            		let obj.src = a:opts.cmd
                            		call F(obj)
                            		return ''
    1              0.000000 	endif
                            
    1              0.000002 	if exists('g:asyncrun_open')
                            		let s:asyncrun_open = g:asyncrun_open
                            		if has_key(a:opts, 'open')
                            			let s:asyncrun_open = a:opts.open
                            		endif
                            		if has_key(a:opts, 'silent')
                            			if a:opts.silent
                            				let s:asyncrun_open = 0
                            			endif
                            		endif
    1              0.000001 	endif
                            
    1              0.000002 	if l:mode == 0 && s:asyncrun_support != 0
    1              0.000003 		let s:async_info.postsave = opts.post
    1              0.000002 		let s:async_info.autosave = opts.auto
    1              0.000002 		let s:async_info.text = opts.text
    1              0.000001 		let s:async_info.raw = opts.raw
    1              0.000002 		let s:async_info.range = opts.range
    1              0.000002 		let s:async_info.range_top = opts.range_top
    1              0.000002 		let s:async_info.range_bot = opts.range_bot
    1              0.000002 		let s:async_info.range_buf = opts.range_buf
    1              0.000001 		let s:async_info.strip = opts.strip
    1              0.000016 		let s:async_info.append = opts.append
    1   0.000919   0.000018 		if s:AsyncRun_Job_Start(l:command) != 0
                            			call s:AutoCmd('Error')
    1              0.000002 		endif
                            	elseif l:mode <= 1 && has('quickfix')
                            		call s:AutoCmd('Pre')
                            		call s:AutoCmd('Start')
                            		let l:makesave = &l:makeprg
                            		let l:script = s:ScriptWrite(l:command, 0)
                            		if s:asyncrun_windows != 0
                            			let &l:makeprg = s:shellescape(l:script)
                            		else
                            			let &l:makeprg = 'source '. s:shellescape(l:script)
                            		endif
                            		let l:efm1 = &g:efm
                            		let l:efm2 = &l:efm
                            		if g:asyncrun_local != 0
                            			let &g:efm = s:async_efm
                            			let &l:efm = s:async_efm
                            		endif
                            		if has('autocmd')
                            			call s:AsyncRun_Job_AutoCmd(0, opts.auto)
                            			exec "noautocmd make!"
                            			call s:AsyncRun_Job_AutoCmd(1, opts.auto)
                            		else
                            			exec "make!"
                            		endif
                            		if g:asyncrun_local != 0
                            			if l:efm1 != &g:efm | let &g:efm = l:efm1 | endif
                            			if l:efm2 != &l:efm | let &l:efm = l:efm2 | endif
                            		endif
                            		let &l:makeprg = l:makesave
                            		if s:asyncrun_windows == 0
                            			try | call delete(l:script) | catch | endtry
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            		call s:AutoCmd('Stop')
                            	elseif l:mode <= 2
                            		let autocmd = get(opts, 'autocmd', 0)
                            		if autocmd != 0
                            			call s:AutoCmd('Pre')
                            			call s:AutoCmd('Start')
                            		endif
                            		exec '!'. escape(l:command, '%#')
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            		if autocmd != 0
                            			call s:AutoCmd('Stop')
                            		endif
                            	elseif l:mode == 3
                            		if s:asyncrun_windows == 0
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		elseif has('nvim')
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		elseif has('python3')
                            			let l:script = s:ScriptWrite(l:command, 0)
                            			py3 import subprocess, vim
                            			py3 argv = {'args': vim.eval('l:script'), 'shell': True}
                            			py3 argv['stdout'] = subprocess.PIPE
                            			py3 argv['stderr'] = subprocess.STDOUT
                            			py3 p = subprocess.Popen(**argv)
                            			py3 text = p.stdout.read()
                            			py3 p.stdout.close()
                            			py3 c = p.wait()
                            			if has('patch-7.4.145')
                            				let l:retval = py3eval('text')
                            				let g:asyncrun_shell_error = py3eval('c')
                            			else
                            				py3 text = text.replace('\\', '\\\\').replace('"', '\\"')
                            				py3 text = text.replace('\n', '\\n').replace('\r', '\\r')
                            				py3 vim.command('let l:retval = "%s"'%text)
                            				py3 vim.command('let g:asyncrun_shell_error = %d'%c)
                            			endif
                            		elseif has('python')
                            			let l:script = s:ScriptWrite(l:command, 0)
                            			py import subprocess, vim
                            			py argv = {'args': vim.eval('l:script'), 'shell': True}
                            			py argv['stdout'] = subprocess.PIPE
                            			py argv['stderr'] = subprocess.STDOUT
                            			py p = subprocess.Popen(**argv)
                            			py text = p.stdout.read()
                            			py p.stdout.close()
                            			py c = p.wait()
                            			if has('patch-7.4.145')
                            				let l:retval = pyeval('text')
                            				let g:asyncrun_shell_error = pyeval('c')
                            			else
                            				py text = text.replace('\\', '\\\\').replace('"', '\\"')
                            				py text = text.replace('\n', '\\n').replace('\r', '\\r')
                            				py vim.command('let l:retval = "%s"'%text)
                            				py vim.command('let g:asyncrun_shell_error = %d'%c)
                            			endif
                            		else
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            	elseif l:mode <= 5
                            		let script = get(g:, 'asyncrun_script', '')
                            		if script != '' && l:mode == 4
                            			let $VIM_COMMAND = l:command
                            			let l:command = script . ' ' . l:command
                            			if s:asyncrun_windows
                            				let ccc = s:shellescape(s:ScriptWrite(l:command, 0))
                            				silent exec '!start /b cmd /C '. ccc
                            			else
                            				call system(l:command . ' &')
                            			endif
                            		elseif s:asyncrun_windows
                            			if l:mode == 4
                            				let l:ccc = s:shellescape(s:ScriptWrite(l:command, 1))
                            				silent exec '!start cmd /C '. l:ccc
                            			else
                            				let l:ccc = s:shellescape(s:ScriptWrite(l:command, 0))
                            				silent exec '!start /b cmd /C '. l:ccc
                            			endif
                            			redraw
                            		else
                            			if l:mode == 4
                            				exec '!' . escape(l:command, '%#')
                            			else
                            				call system(l:command . ' &')
                            			endif
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            	elseif l:mode == 6
                            		let opts.cmd = l:command
                            		call s:start_in_terminal(opts)
    1              0.000001 	endif
                            
    1              0.000001 	return l:retval

FUNCTION  asyncrun#get_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1066
Called 1 time
Total time:   0.000953
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000005 	let markers = ['.project', '.git', '.hg', '.svn', '.root']
    1              0.000004 	if exists('g:asyncrun_rootmarks')
                            		let markers = g:asyncrun_rootmarks
    1              0.000000 	endif
    1              0.000002 	if a:0 > 0
                            		if type(a:1) == type([])
                            			let markers = a:1
                            		endif
    1              0.000001 	endif
    1              0.000003 	let strict = (a:0 >= 2)? (a:2) : 0
    1   0.000922   0.000010 	let l:hr = s:find_root(a:path, markers, strict)
    1              0.000001 	if s:asyncrun_windows
                            		let l:hr = s:StringReplace(l:hr, '/', "\\")
    1              0.000001 	endif
    1              0.000002 	return l:hr

FUNCTION  <SNR>3_AutoCmd()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:221
Called 2 times
Total time:   0.000120
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000007 	if has('autocmd') && ((g:asyncrun_skip / 2) % 2) == 0
    2              0.000003 		if g:asyncrun_silent
    2   0.000101   0.000054 			exec 'silent doautocmd User AsyncRun'.a:name
                            		else
                            			exec 'doautocmd User AsyncRun'.a:name
    2              0.000001 		endif
    2              0.000001 	endif

FUNCTION  <SNR>3_ExtractOpt()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:868
Called 1 time
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
    1              0.000003 	let cmd = a:command
    1              0.000002 	let opts = {}
    1              0.000015 	while cmd =~# '^-\%(\w\+\)\%([= ]\|$\)'
                            		let opt = matchstr(cmd, '^-\zs\w\+')
                            		if cmd =~ '^-\w\+='
                            			let val = matchstr(cmd, '^-\w\+=\zs\%(\\.\|\S\)*')
                            		else
                            			let val = (opt == 'cwd')? '' : 1
                            		endif
                            		let opts[opt] = substitute(val, '\\\(\s\)', '\1', 'g')
                            		let cmd = substitute(cmd, '^-\w\+\%(=\%(\\.\|\S\)*\)\=\s*', '', '')
    1              0.000001 	endwhile
    1              0.000176 	let cmd = substitute(cmd, '^\s*\(.\{-}\)\s*$', '\1', '')
    1              0.000008 	let cmd = substitute(cmd, '^@\s*', '', '')
    1              0.000004 	let opts.cwd = get(opts, 'cwd', '')
    1              0.000003 	let opts.mode = get(opts, 'mode', '')
    1              0.000002 	let opts.save = get(opts, 'save', '')
    1              0.000003 	let opts.program = get(opts, 'program', '')
    1              0.000003 	let opts.post = get(opts, 'post', '')
    1              0.000002 	let opts.text = get(opts, 'text', '')
    1              0.000002 	let opts.auto = get(opts, 'auto', '')
    1              0.000002 	let opts.raw = get(opts, 'raw', '')
    1              0.000003 	let opts.strip = get(opts, 'strip', '')
    1              0.000003 	let opts.append = get(opts, 'append', '')
    1              0.000001 	if 0
                            		echom 'cwd:'. opts.cwd
                            		echom 'mode:'. opts.mode
                            		echom 'save:'. opts.save
                            		echom 'program:'. opts.program
                            		echom 'command:'. cmd
    1              0.000001 	endif
    1              0.000003 	return [cmd, opts]

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  300   0.054308   0.013854  SetStatusLine()
  201   0.023384             <SNR>5_ManageWinStl()
  300   0.017001   0.012224  <SNR>5_GitInit()
  300   0.013995   0.009258  <SNR>5_BuildFilenameLbl()
  300   0.009458             <SNR>5_BuildInfBar()
    1   0.004777   0.000198  <SNR>5_GitUpdate()
  300   0.004737             <SNR>5_GetFilename()
    1   0.004579   0.001239  asyncrun#run()
    1   0.001487   0.000433  <SNR>3_run()
    1   0.000953   0.000041  asyncrun#get_root()
    1   0.000912   0.000070  <SNR>3_find_root()
    1   0.000901   0.000757  <SNR>3_AsyncRun_Job_Start()
    1   0.000789   0.000338  <SNR>3_guess_root()
   54   0.000452             <SNR>3_StringReplace()
    7   0.000375             <SNR>3_path_join()
    2   0.000339             <SNR>3_StringStrip()
    1   0.000262             <SNR>3_ExtractOpt()
    2   0.000129             asyncrun#fullname()
    2   0.000120   0.000073  <SNR>3_AutoCmd()
    1   0.000024             <SNR>3_AsyncRun_Job_AutoCmd()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  201              0.023384  <SNR>5_ManageWinStl()
  300   0.054308   0.013854  SetStatusLine()
  300   0.017001   0.012224  <SNR>5_GitInit()
  300              0.009458  <SNR>5_BuildInfBar()
  300   0.013995   0.009258  <SNR>5_BuildFilenameLbl()
  300              0.004737  <SNR>5_GetFilename()
    1   0.004579   0.001239  asyncrun#run()
    1   0.000901   0.000757  <SNR>3_AsyncRun_Job_Start()
   54              0.000452  <SNR>3_StringReplace()
    1   0.001487   0.000433  <SNR>3_run()
    7              0.000375  <SNR>3_path_join()
    2              0.000339  <SNR>3_StringStrip()
    1   0.000789   0.000338  <SNR>3_guess_root()
    1              0.000262  <SNR>3_ExtractOpt()
    1   0.004777   0.000198  <SNR>5_GitUpdate()
    2              0.000129  asyncrun#fullname()
    2   0.000120   0.000073  <SNR>3_AutoCmd()
    1   0.000912   0.000070  <SNR>3_find_root()
    1   0.000953   0.000041  asyncrun#get_root()
    1              0.000024  <SNR>3_AsyncRun_Job_AutoCmd()

