FUNCTION  <SNR>3_StringReplace()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:857
Called 54 times
Total time:   0.000587
 Self time:   0.000587

count  total (s)   self (s)
   54              0.000403 	let l:data = split(a:text, a:old, 1)
   54              0.000158 	return join(l:data, a:new)

FUNCTION  <SNR>3_AsyncRun_Job_AutoCmd()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:446
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000006 	if !has('autocmd') | return | endif
    1              0.000003 	let name = (a:auto == '')? g:asyncrun_auto : a:auto
    1              0.000015 	if name !~ '^\w\+$' || name == 'NONE' || name == '<NONE>'
    1              0.000001 		return
                            	endif
                            	if ((g:asyncrun_skip / 4) % 2) != 0
                            		return 0
                            	endif
                            	if a:mode == 0
                            		if g:asyncrun_silent
                            			silent exec 'doautocmd QuickFixCmdPre '. name
                            		else
                            			exec 'doautocmd QuickFixCmdPre '. name
                            		endif
                            	else
                            		if g:asyncrun_silent
                            			silent exec 'doautocmd QuickFixCmdPost '. name
                            		else
                            			exec 'doautocmd QuickFixCmdPost '. name
                            		endif
                            	endif

FUNCTION  <SNR>3_AsyncRun_Job_Start()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:628
Called 1 time
Total time:   0.001006
 Self time:   0.000844

count  total (s)   self (s)
    1              0.000001 	let l:running = 0
    1              0.000001 	let l:empty = 0
    1              0.000001 	if s:asyncrun_support == 0
                            		call s:NotSupport()
                            		return -1
    1              0.000001 	endif
    1              0.000002 	if exists('s:async_job')
                            		if !has('nvim')
                            			if job_status(s:async_job) == 'run'
                            				let l:running = 1
                            			endif
                            		else
                            			if s:async_job > 0
                            				let l:running = 1
                            			endif
                            		endif
    1              0.000000 	endif
    1              0.000003 	if type(a:cmd) == 1
    1              0.000003 		if a:cmd == '' | let l:empty = 1 | endif
                            	elseif type(a:cmd) == 3
                            		if a:cmd == [] | let l:empty = 1 | endif
    1              0.000001 	endif
    1              0.000002 	if s:async_state != 0 || l:running != 0
                            		call s:ErrorMsg("background job is still running")
                            		return -2
    1              0.000000 	endif
    1              0.000002 	if l:empty != 0
                            		call s:ErrorMsg("empty arguments")
                            		return -3
    1              0.000000 	endif
    1              0.000002 	let l:args = []
    1              0.000001 	if g:asyncrun_shell == ''
    1              0.000014 		let l:args += split(&shell)
    1              0.000005 		let l:args += split(&shellcmdflag)
                            	else
                            		let l:args += split(g:asyncrun_shell)
                            		let l:args += split(g:asyncrun_shellflag)
    1              0.000001 	endif
    1              0.000003 	let s:async_info.errorformat = s:async_efm
    1              0.000001 	let l:name = []
    1              0.000002 	if type(a:cmd) == 1
    1              0.000002 		let l:name = a:cmd
    1              0.000001 		if s:asyncrun_windows == 0
    1              0.000003 			let l:args += [a:cmd]
                            		else
                            			let l:tmp = s:ScriptWrite(a:cmd, 0)
                            			if s:async_nvim == 0
                            				let l:args += [l:tmp]
                            			else
                            				let l:args = s:shellescape(l:tmp)
                            			endif
    1              0.000001 		endif
                            	elseif type(a:cmd) == 3
                            		if s:asyncrun_windows == 0
                            			let l:temp = []
                            			for l:item in a:cmd
                            				if index(['|', '`'], l:item) < 0
                            					let l:temp += [fnameescape(l:item)]
                            				else
                            					let l:temp += ['|']
                            				endif
                            			endfor
                            			let l:args += [join(l:temp, ' ')]
                            		else
                            			let l:args += a:cmd
                            		endif
                            		let l:vector = []
                            		for l:x in a:cmd
                            			let l:vector += ['"'.l:x.'"']
                            		endfor
                            		let l:name = join(l:vector, ', ')
    1              0.000000 	endif
    1              0.000002 	let s:async_state = 0
    1              0.000002 	let s:async_output = {}
    1              0.000001 	let s:async_head = 0
    1              0.000001 	let s:async_tail = 0
    1              0.000003 	let s:async_info.post = s:async_info.postsave
    1              0.000002 	let s:async_info.auto = s:async_info.autosave
    1              0.000001 	let s:async_info.postsave = ''
    1              0.000001 	let s:async_info.autosave = ''
    1              0.000001 	let g:asyncrun_text = s:async_info.text
    1   0.000052   0.000008 	call s:AutoCmd('Pre')
    1              0.000002 	if s:async_nvim == 0
    1              0.000002 		let l:options = {}
    1              0.000009 		let l:options['callback'] = function('s:AsyncRun_Job_OnCallback')
    1              0.000004 		let l:options['close_cb'] = function('s:AsyncRun_Job_OnClose')
    1              0.000004 		let l:options['exit_cb'] = function('s:AsyncRun_Job_OnExit')
    1              0.000002 		let l:options['out_io'] = 'pipe'
    1              0.000002 		let l:options['err_io'] = 'out'
    1              0.000001 		let l:options['in_io'] = 'null'
    1              0.000002 		let l:options['out_mode'] = 'nl'
    1              0.000002 		let l:options['err_mode'] = 'nl'
    1              0.000001 		let l:options['stoponexit'] = 'term'
    1              0.000004 		if g:asyncrun_stop != ''
                            			let l:options['stoponexit'] = g:asyncrun_stop
    1              0.000001 		endif
    1              0.000002 		if s:async_info.range > 0
                            			let l:options['in_io'] = 'buffer'
                            			let l:options['in_mode'] = 'nl'
                            			let l:options['in_buf'] = s:async_info.range_buf
                            			let l:options['in_top'] = s:async_info.range_top
                            			let l:options['in_bot'] = s:async_info.range_bot
    1              0.000003 		elseif exists('*ch_close_in')
    1              0.000002 			if g:asyncrun_stdin != 0
                            				let l:options['in_io'] = 'pipe'
    1              0.000001 			endif
    1              0.000000 		endif
    1              0.000400 		let s:async_job = job_start(l:args, l:options)
    1              0.000016 		let l:success = (job_status(s:async_job) != 'fail')? 1 : 0
    1              0.000003 		if l:success && l:options['in_io'] == 'pipe'
                            			silent! call ch_close_in(job_getchannel(s:async_job))
    1              0.000001 		endif
                            	else
                            		let l:callbacks = {'shell': 'AsyncRun'}
                            		let l:callbacks['on_stdout'] = function('s:AsyncRun_Job_NeoVim')
                            		let l:callbacks['on_stderr'] = function('s:AsyncRun_Job_NeoVim')
                            		let l:callbacks['on_exit'] = function('s:AsyncRun_Job_NeoVim')
                            		let s:neovim_stdout = ''
                            		let s:neovim_stderr = ''
                            		let s:async_job = jobstart(l:args, l:callbacks)
                            		let l:success = (s:async_job > 0)? 1 : 0
                            		if l:success != 0
                            			if s:async_info.range > 0
                            				let l:top = s:async_info.range_top
                            				let l:bot = s:async_info.range_bot
                            				let l:lines = getline(l:top, l:bot)
                            				if exists('*chansend')
                            					call chansend(s:async_job, l:lines)
                            				elseif exists('*jobsend')
                            					call jobsend(s:async_job, l:lines)
                            				endif
                            			endif
                            			if exists('*chanclose')
                            				call chanclose(s:async_job, 'stdin')
                            			elseif exists('*jobclose')
                            				call jobclose(s:async_job, 'stdin')
                            			endif
                            		endif
    1              0.000009 	endif
    1              0.000001 	if l:success != 0
    1              0.000006 		let s:async_state = or(s:async_state, 1)
    1              0.000003 		let g:asyncrun_status = "running"
    1              0.000002 		let s:async_start = localtime()
    1              0.000003 		let l:arguments = "[".l:name."]"
    1              0.000006 		let l:title = ':AsyncRun '.l:name
    1              0.000002 		if !s:async_info.append
    1              0.000001 			if s:async_nvim == 0
    1              0.000003 				if v:version >= 800 || has('patch-7.4.2210')
    1              0.000030 					call setqflist([], ' ', {'title':l:title})
                            				else
                            					call setqflist([], ' ')
    1              0.000001 				endif
                            			else
                            				call setqflist([], ' ', l:title)
    1              0.000001 			endif
    1              0.000001 		endif
    1              0.000001 		if !s:async_info.strip
    1              0.000006 			call setqflist([{'text':l:arguments}], 'a')
    1              0.000001 		endif
    1              0.000002 		let l:name = 'g:AsyncRun_Job_OnTimer'
    1              0.000009 		let s:async_timer = timer_start(100, l:name, {'repeat':-1})
    1   0.000065   0.000040 		call s:AsyncRun_Job_AutoCmd(0, s:async_info.auto)
    1   0.000126   0.000033 		call s:AutoCmd('Start')
    1              0.000002 		redrawstatus!
                            	else
                            		unlet s:async_job
                            		call s:ErrorMsg("Background job start failed '".a:cmd."'")
                            		redrawstatus!
                            		return -5
    1              0.000001 	endif
    1              0.000002 	return 0

FUNCTION  <SNR>3_find_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1008
Called 1 time
Total time:   0.001008
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000004 	function! s:guess_root(filename, markers)
                            		let fullname = asyncrun#fullname(a:filename)
                            		if fullname =~ '^fugitive:/'
                            			if exists('b:git_dir')
                            				return fnamemodify(b:git_dir, ':h')
                            			endif
                            			return '' " skip any fugitive buffers early
                            		endif
                            		let pivot = fullname
                            		if !isdirectory(pivot)
                            			let pivot = fnamemodify(pivot, ':h')
                            		endif
                            		while 1
                            			let prev = pivot
                            			for marker in a:markers
                            				let newname = s:path_join(pivot, marker)
                            				if newname =~ '[\*\?\[\]]'
                            					if glob(newname) != ''
                            						return pivot
                            					endif
                            				elseif filereadable(newname)
                            					return pivot
                            				elseif isdirectory(newname)
                            					return pivot
                            				endif
                            			endfor
                            			let pivot = fnamemodify(pivot, ':h')
                            			if pivot == prev
                            				break
                            			endif
                            		endwhile
                                    return ''
                            	endfunc
    1              0.000002 	if a:path == '%'
    1              0.000004 		if exists('b:asyncrun_root') && b:asyncrun_root != ''
                            			return b:asyncrun_root
    1              0.000003 		elseif exists('t:asyncrun_root') && t:asyncrun_root != ''
                            			return t:asyncrun_root
    1              0.000002 		elseif exists('g:asyncrun_root') && g:asyncrun_root != ''
                            			return g:asyncrun_root
    1              0.000000 		endif
    1              0.000000 	endif
    1   0.000899   0.000012 	let root = s:guess_root(a:path, a:markers)
    1              0.000002 	if root != ''
    1   0.000061   0.000008 		return asyncrun#fullname(root)
                            	elseif a:strict != 0
                            		return ''
                            	endif
                            	" Not found: return parent directory of current file / file itself.
                            	let fullname = asyncrun#fullname(a:path)
                            	if isdirectory(fullname)
                            		return fullname
                            	endif
                            	return asyncrun#fullname(fnamemodify(fullname, ':h'))

FUNCTION  <SNR>5_GitInit()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:315
Called 900 times
Total time:   0.047550
 Self time:   0.041914

count  total (s)   self (s)
                            
  900              0.002825     if !has_key(s:GitStatus, a:buf)
    1              0.000016         let s:GitStatus[a:buf] = {"LocalEnable" : 1 ,"IsGit": 0, "RootDir": "", "BranchName": "",  "Dirty": "", "IsTracked": 0, "InsertNum": 0, "DeleteNum": 0, "CacheExpired": 0}
  900              0.000570     endif
                            
  900              0.002860     if !s:GitStatus["enabled"] || !s:GitStatus[a:buf]["LocalEnable"]
                                    return
  900              0.000416     endif
                            
  900              0.015003     let l:flname = expand("#" . a:buf . ":p")
                                " If we opened a dir or taglist, ignore.
  900              0.005948     if !filereadable(l:flname)
                                    let s:GitStatus[a:buf]["LocalEnable"] = 0
                                    return
  900              0.000507     endif 
                            
  900              0.002118     if s:GitStatus[a:buf]["CacheExpired"] > 0
                                    " Dont update unless it has been a while
  899              0.002532         let s:GitStatus[a:buf]["CacheExpired"] -= 1
  899              0.000689         return
    1              0.000001     endif
                            
                                " Renew Cache after update
    1              0.000004     let s:GitStatus[a:buf]["CacheExpired"] = s:GitMaxCacheExp
                            
    1   0.005649   0.000013     call s:GitUpdate(1, a:buf)
                            

FUNCTION  <SNR>3_check_quickfix()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:2003
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000018 		let height = get(g:, "asyncrun_open", 0)
    1              0.000002 		if exists('s:asyncrun_open')
                            			let height = s:asyncrun_open
    1              0.000001 		endif
                            		" echo 'height: '.height . ' ' .s:asyncrun_open
    1              0.000001 		if height > 0
                            			call asyncrun#quickfix_toggle(height, 1)
    1              0.000000 		endif

FUNCTION  <SNR>3_StringStrip()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:863
Called 2 times
Total time:   0.000397
 Self time:   0.000397

count  total (s)   self (s)
    2              0.000396 	return substitute(a:text, '^\s*\(.\{-}\)\s*$', '\1', '')

FUNCTION  <SNR>3_guess_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1009
Called 1 time
Total time:   0.000887
 Self time:   0.000415

count  total (s)   self (s)
    1   0.000107   0.000027 		let fullname = asyncrun#fullname(a:filename)
    1              0.000006 		if fullname =~ '^fugitive:/'
                            			if exists('b:git_dir')
                            				return fnamemodify(b:git_dir, ':h')
                            			endif
                            			return '' " skip any fugitive buffers early
    1              0.000000 		endif
    1              0.000002 		let pivot = fullname
    1              0.000006 		if !isdirectory(pivot)
    1              0.000003 			let pivot = fnamemodify(pivot, ':h')
    1              0.000000 		endif
    2              0.000004 		while 1
    2              0.000005 			let prev = pivot
    8              0.000015 			for marker in a:markers
    7   0.000467   0.000075 				let newname = s:path_join(pivot, marker)
    7              0.000061 				if newname =~ '[\*\?\[\]]'
                            					if glob(newname) != ''
                            						return pivot
                            					endif
    7              0.000076 				elseif filereadable(newname)
                            					return pivot
    7              0.000029 				elseif isdirectory(newname)
    1              0.000002 					return pivot
    6              0.000004 				endif
    7              0.000007 			endfor
    1              0.000006 			let pivot = fnamemodify(pivot, ':h')
    1              0.000002 			if pivot == prev
                            				break
    1              0.000001 			endif
    1              0.000001 		endwhile
                                    return ''

FUNCTION  <SNR>3_path_join()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:975
Called 7 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
    7              0.000024     let l:size = strlen(a:home)
    7              0.000029     if l:size == 0 | return a:name | endif
    7              0.000028     let l:last = strpart(a:home, l:size - 1, 1)
    7              0.000067     if has("win32") || has("win64") || has("win16") || has('win95')
                            		let l:first = strpart(a:name, 0, 1)
                            		if l:first == "/" || l:first == "\\"
                            			let head = strpart(a:home, 1, 2)
                            			if index([":\\", ":/"], head) >= 0
                            				return strpart(a:home, 0, 2) . a:name
                            			endif
                            			return a:name
                            		elseif index([":\\", ":/"], strpart(a:name, 1, 2)) >= 0
                            			return a:name
                            		endif
                                    if l:last == "/" || l:last == "\\"
                                        return a:home . a:name
                                    else
                                        return a:home . '/' . a:name
                                    endif
    7              0.000005     else
    7              0.000019 		if strpart(a:name, 0, 1) == "/"
                            			return a:name
    7              0.000007 		endif
    7              0.000009         if l:last == "/"
                                        return a:home . a:name
    7              0.000004         else
    7              0.000018             return a:home . '/' . a:name
                                    endif
                                endif

FUNCTION  <SNR>5_GitUpdate()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:275
Called 1 time
Total time:   0.005636
 Self time:   0.000208

count  total (s)   self (s)
    1              0.000006     let l:buf = get(a:, 1, bufnr())
                            
    1              0.000004     if !s:GitStatus["enabled"] || !s:GitStatus[l:buf]["LocalEnable"]
                                    return
    1              0.000000     endif
                                
    1              0.000021     let l:flname = expand("#" . l:buf . ":p")
    1              0.000005     let l:parentDir = fnamemodify(l:flname, ":h")
    1              0.000079     let l:tmpfile = tempname()
    1              0.000005     let l:redir = l:tmpfile ." 2> /dev/null "
    1              0.000004     let l:isFullUpdate = a:initOrWrite || !s:GitStatus[l:buf]["IsGit"]
    1              0.000002     let l:cmd = ""
                            
    1              0.000001     if l:isFullUpdate
    1              0.000005         let l:cmd  = "git -C " . l:parentDir . " rev-parse --absolute-git-dir > " . l:redir . "&& "
    1              0.000005         let l:cmd .= "(git -C " . l:parentDir . " symbolic-ref HEAD || " 
    1              0.000005         let l:cmd .= "git -C " . l:parentDir . " rev-parse --short HEAD) >> " . l:redir . "&& "
    1              0.000001     endif
                            
    1              0.000007     let l:cmd .= "([[ -n $(git -C " . l:parentDir . " ls-files " . l:flname . ") ]] && " .  "echo '1'  || echo '0') >> " . l:redir . "&& "
    1              0.000005     let l:cmd .= "([[ -z $(git -C " . l:parentDir . " status -s) ]] || echo '*') >> " . l:redir . "&& "
    1              0.000006     let l:cmd .= "git -C " . l:parentDir . " diff --numstat -- " . l:flname . " >> " . l:redir
                                
    1              0.000002     if g:asyncrun_status != "running"
                                    " Async call to g:AsyncGitCallback()
    1   0.005457   0.000029         call asyncrun#run("",  {"post": "call g:AsyncGitCallback(" . l:isFullUpdate . ", '" . l:tmpfile . "', " .  l:buf . ")"}, l:cmd)
                                else
                                    " If we could not execute it now, void the cache so that it is executed
                                    " the next time 
                                    let s:GitStatus[l:buf]["CacheExpired"] = 0
    1              0.000002     endif

FUNCTION  SetStatusLine()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:139
Called 900 times
Total time:   0.164548
 Self time:   0.041273

count  total (s)   self (s)
  900              0.003284     let l:winnum = win_id2win(a:winid)
  900              0.001979     let l:buf = winbufnr(l:winnum)
  900              0.002194     let l:isActiveWindow = (l:winnum == winnr())
                                
                                " Initialize Git
  900   0.052833   0.005283     call s:GitInit(l:buf)
                            
                                " Mode
  900              0.004157     let l:sts = s:modeMap[l:isActiveWindow][a:nextToTaglist][mode()]
                            
                                " File or function name
  900   0.054141   0.007207     let l:sts .= s:BuildFilenameLbl(l:buf, l:isActiveWindow)
                             
                                " Left align
  900              0.001217     let l:sts .= "%="
                                
                            
                                " Modified flag
  900              0.004634     let l:sts .= s:modifiedFlag[getbufvar(l:buf, "&modified")][l:isActiveWindow]
                              
                                " Information bar
  900   0.034898   0.006107     let l:sts .= s:BuildInfBar(l:buf, l:isActiveWindow)
                            
  900              0.001025     return l:sts

FUNCTION  <SNR>5_ManageWinStl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:176
Called 601 times
Total time:   0.073757
 Self time:   0.073757

count  total (s)   self (s)
  601              0.002307     let l:bottomRightWin = winnr('$')
  601              0.000944     let l:taglistWin = -1
                            
 1502              0.003003     for n in range(1, bottomRightWin)
  901              0.002207         let l:wintype = win_gettype(n)
                            
                                    " Ignore popup & autocmd
  901              0.001812         if (l:wintype !=# 'popup' || l:wintype !=# 'autocmd')
  901              0.001712             let l:bufnum = winbufnr(n)
  901              0.002263             let l:winbufname = bufname(l:bufnum)
  901              0.001745             let l:winid = win_getid(n)
  901              0.003714             let l:isPrv = getwinvar(n, "&pvw")
  901              0.008944             let l:isHelp = getbufvar(l:winbufname, "&ft") ==# "help"
  901              0.002668             let l:isQf = getwinvar(n, '&syntax') == 'qf'
                            
  901              0.001482             if l:winbufname ==# g:TagList_title
                                            " Set the taglist status line
                                            call setwinvar(n, '&statusline', "%!SetTaglistSts()")
                                            let l:taglistWin = n
                            
  901              0.002173             elseif l:isPrv || l:isHelp || l:isQf || l:wintype ==# "command"
                                            " Set straight line
                                            call setwinvar(n, '&statusline',  "%#StraightLine#%{" .  "repeat('‚îÅ',\ winwidth(win_id2win(".l:winid.")))" .  "}")
                            
  901              0.003980             elseif (n == l:bottomRightWin) &&  ((winwidth(n) + winwidth(1) + 1 ) == &columns) &&  l:taglistWin == 1
                            
                                            " Only two windows in the bottom
                                            " Two arrows for mode label
                                            call setwinvar(n, '&statusline', "%!SetStatusLine(".l:winid.", 1)")
                            
  901              0.000586             else
                                            " Other windows status lines
  901              0.004657                 call setwinvar(n, '&statusline', "%!SetStatusLine(".l:winid.", 0)")
  901              0.000697             end
                            
  901              0.000457         endif
                            
 1502              0.001512     endfor

FUNCTION  asyncrun#run()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1689
Called 1 time
Total time:   0.005428
 Self time:   0.001609

count  total (s)   self (s)
    1              0.000003 	let l:macros = {}
    1              0.000025 	let l:macros['VIM_FILEPATH'] = expand("%:p")
    1              0.000004 	let l:macros['VIM_FILENAME'] = expand("%:t")
    1              0.000015 	let l:macros['VIM_FILEDIR'] = expand("%:p:h")
    1              0.000004 	let l:macros['VIM_FILENOEXT'] = expand("%:t:r")
    1              0.000013 	let l:macros['VIM_PATHNOEXT'] = expand("%:p:r")
    1              0.000004 	let l:macros['VIM_FILEEXT'] = "." . expand("%:e")
    1              0.000002 	let l:macros['VIM_FILETYPE'] = (&filetype)
    1              0.000005 	let l:macros['VIM_CWD'] = getcwd()
    1              0.000004 	let l:macros['VIM_RELDIR'] = expand("%:h:.")
    1              0.000015 	let l:macros['VIM_RELNAME'] = expand("%:p:.")
    1              0.000005 	let l:macros['VIM_CWORD'] = expand("<cword>")
    1              0.000005 	let l:macros['VIM_CFILE'] = expand("<cfile>")
    1              0.000003 	let l:macros['VIM_CLINE'] = line('.')
    1              0.000003 	let l:macros['VIM_VERSION'] = ''.v:version
    1              0.000003 	let l:macros['VIM_SVRNAME'] = v:servername
    1              0.000003 	let l:macros['VIM_COLUMNS'] = ''.&columns
    1              0.000003 	let l:macros['VIM_LINES'] = ''.&lines
    1              0.000008 	let l:macros['VIM_GUI'] = has('gui_running')? 1 : 0
    1   0.001063   0.000013 	let l:macros['VIM_ROOT'] = asyncrun#get_root('%')
    1              0.000023     let l:macros['VIM_HOME'] = expand(split(&rtp, ',')[0])
    1              0.000006 	let l:macros['VIM_PRONAME'] = fnamemodify(l:macros['VIM_ROOT'], ':t')
    1              0.000004 	let l:macros['VIM_DIRNAME'] = fnamemodify(l:macros['VIM_CWD'], ':t')
    1              0.000002 	let l:macros['VIM_PWD'] = l:macros['VIM_CWD']
    1              0.000003 	let l:macros['<cwd>'] = l:macros['VIM_CWD']
    1              0.000002 	let l:macros['<root>'] = l:macros['VIM_ROOT']
    1              0.000003 	let l:macros['<pwd>'] = l:macros['VIM_PWD']
    1              0.000002 	let l:retval = ''
                            
                            	" handle: empty extension
    1              0.000003 	if expand("%:e") == ''
                            		let l:macros['VIM_FILEEXT'] = ''
    1              0.000001 	endif
                            
                            	" extract options
    1   0.000545   0.000033 	let [l:command, l:opts] = s:ExtractOpt(s:StringStrip(a:args))
                            
                            	" check lazy load
    1              0.000005 	if get(l:opts, 'mode', '') == 'load'
                            		return ''
    1              0.000001 	endif
                            
                            	" combine options
    1              0.000004 	if type(a:opts) == type({})
    2              0.000007 		for [l:key, l:val] in items(a:opts)
    1              0.000004 			let l:opts[l:key] = l:val
    2              0.000003 		endfor
    1              0.000001 	endif
                            
                            	" parse makeprg/grepprg and return
    1              0.000003 	if l:opts.program == 'parse'
                            		let s:async_program_cmd = l:command
                            		return s:async_program_cmd
    1              0.000001 	endif
                            
                            	" update marcros
    1              0.000005 	let l:macros['VIM_RUNNAME'] = get(l:opts, 'name', '')
                            
                            	" update info (current running command text)
    1              0.000003 	let g:asyncrun_info = a:args
                            
                            	" setup range
    1              0.000002 	let l:opts.range = 0
    1              0.000002 	let l:opts.range_top = 0
    1              0.000001 	let l:opts.range_bot = 0
    1              0.000002 	let l:opts.range_buf = 0
                            
    1              0.000002 	if a:0 >= 3
                            		if a:1 > 0 && a:2 <= a:3
                            			let l:opts.range = 2
                            			let l:opts.range_top = a:2
                            			let l:opts.range_bot = a:3
                            			let l:opts.range_buf = bufnr('%')
                            		endif
    1              0.000001 	endif
                            
                            	" check cwd
    1              0.000002 	if l:opts.cwd != ''
                            		for [l:key, l:val] in items(l:macros)
                            			let l:replace = (l:key[0] != '<')? '$('.l:key.')' : l:key
                            			let l:opts.cwd = s:StringReplace(l:opts.cwd, l:replace, l:val)
                            		endfor
                            		let l:opts.savecwd = getcwd()
                            		silent! call s:chdir(l:opts.cwd)
                            		let l:macros['VIM_CWD'] = getcwd()
                            		let l:macros['VIM_RELDIR'] = expand("%:h:.")
                            		let l:macros['VIM_RELNAME'] = expand("%:p:.")
                            		let l:macros['VIM_CFILE'] = expand("<cfile>")
                            		let l:macros['VIM_DIRNAME'] = fnamemodify(l:macros['VIM_CWD'], ':t')
                            		let l:macros['<cwd>'] = l:macros['VIM_CWD']
    1              0.000000 	endif
                            
                            	" windows can use $(WSL_XXX)
    1              0.000002 	if s:asyncrun_windows != 0
                            		let wslnames = ['FILEPATH', 'FILENAME', 'FILEDIR', 'FILENOEXT']
                            		let wslnames += ['PATHNOEXT', 'FILEEXT', 'FILETYPE', 'RELDIR']
                            		let wslnames += ['RELNAME', 'CFILE', 'ROOT', 'HOME', 'CWD']
                            		for name in wslnames
                            			let src = l:macros['VIM_' . name]
                            			let l:macros['WSL_' . name] = asyncrun#path_win2unix(src, '/mnt')
                            		endfor
    1              0.000001 	endif
                            
                            	" replace macros and setup environment variables
   28              0.000072 	for [l:key, l:val] in items(l:macros)
   27              0.000148 		let l:replace = (l:key[0] != '<')? '$('.l:key.')' : l:key
   27              0.000061 		if l:key[0] != '<'
   24              0.000068 			if strpart(l:key, 0, 4) != 'WSL_'
   24              0.000173 				exec 'let $'.l:key.' = l:val'
   24              0.000019 			endif
   27              0.000019 		endif
   27   0.000653   0.000287 		let l:command = s:StringReplace(l:command, l:replace, l:val)
   27   0.000460   0.000239 		let l:opts.text = s:StringReplace(l:opts.text, l:replace, l:val)
   28              0.000027 	endfor
                            
                            	" config
    1              0.000006 	let l:opts.cmd = l:command
    1              0.000003 	let l:opts.macros = l:macros
    1              0.000006 	let l:opts.mode = get(l:opts, 'mode', g:asyncrun_mode)
    1              0.000008 	let l:opts.errorformat = get(l:opts, 'errorformat', &errorformat)
    1              0.000004 	let s:async_scroll = (a:bang == '!')? 0 : 1
                            
                            	" check if need to save
    1              0.000003 	let l:save = get(l:opts, 'save', '')
                            
    1              0.000001 	if l:save == ''
    1              0.000003 		let l:save = ''. g:asyncrun_save
    1              0.000000 	endif
                            
    1              0.000001 	if l:save == '1'
                            		silent! update
    1              0.000002 	elseif l:save
                            		silent! wall
    1              0.000001 	endif
                            
                            	" run command
    1   0.001689   0.000019 	let l:retval = s:run(l:opts)
                            
                            	" restore cwd
    1              0.000002 	if l:opts.cwd != ''
                            		silent! call s:chdir(l:opts.savecwd)
    1              0.000001 	endif
                            
    1              0.000005 	return l:retval

FUNCTION  MeasureTime()
    Defined: ~/.vim/bundle/long-statusline/plugin/vimrc.test:8
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
  301              0.001070     for l:i in range(a:iter)
  300   0.076820   0.028555       vsplit
  300              0.503630       redraw
  300   0.064992   0.030289       quit
  300              0.173186       redraw
  301              0.000469     endfor
                                qa

FUNCTION  <SNR>5_BuildInfBar()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:105
Called 900 times
Total time:   0.028791
 Self time:   0.028791

count  total (s)   self (s)
  900              0.002149     let l:infBHighlight = (a:isActiveWindow)? "InfB" : "DisInfB"
  900              0.002320     let l:infBar = s:lASym . "%#" . l:infBHighlight . "# "
                            
  900              0.001688     if s:GitStatus[a:buf]["IsGit"]
                                    let l:infBar .= s:gitBranchSym . " " .  s:GitStatus[a:buf]["BranchName"] . s:GitStatus[a:buf]["Dirty"]
                            
                                    let l:infBar .= "%#" . l:infBHighlight . "Strick#" .  s:sepASym . "  %#" . l:infBHighlight . "#"
                                    
                                    if s:GitStatus[a:buf]["IsTracked"]
                                        let l:infBar .= s:gitInsSym . " " . s:GitStatus[a:buf]["InsertNum"] . " "
                                        let l:infBar .= s:gitDelSym . " " . s:GitStatus[a:buf]["DeleteNum"]
                                    else
                                        let l:infBar .= s:gitUnTckSym
                                    endif
                            
                                    let l:infBar .= "%#" . l:infBHighlight . "Strick#" .  s:sepASym . "  %#" . l:infBHighlight . "#"
                            
  900              0.000440     endif
                              
  900              0.004292     let l:infBar .= s:cnumSym . " %c" . "%#" . l:infBHighlight .  "Strick#" . s:sepASym . "  %#" . l:infBHighlight . "#"
                            
  900              0.001643     let l:infBar .= s:lnumSym . " %l"
  900              0.002620     let l:infBar .= " %#RCSep" . l:infBHighlight . "#" .  s:sepBSym . "  %#RC#%2P "
                            
  900              0.000985     return l:infBar

FUNCTION  <SNR>5_BuildFilenameLbl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:79
Called 900 times
Total time:   0.046934
 Self time:   0.027817

count  total (s)   self (s)
  900              0.004589     let l:bufreadonly = getbufvar(a:buf, "&readonly") ||  (getbufvar(a:buf, "&modifiable") == 0)
                            
  900   0.026703   0.007586     let l:middleText = "%#FlnLbl#" . s:GetFilename(a:buf)  . " " .  ((l:bufreadonly) ? s:readonlySym . " " : "")
                            
  900              0.001552     let l:md = mode()
  900              0.002053     if (l:md ==? "i" || l:md ==# "R") && (a:isActiveWindow)
                                    " Consult Taglist about nearby tag
                                    let l:funcProto = Tlist_Get_Tag_Prototype_By_Line()
                            
                                    if (len(l:funcProto))
                                        " Show function name instead in insert or replace mode
                                        let l:middleText = "%#FuncLbl#" . s:tagNameSym .  " " . s:RightTruncate(l:funcProto,  (winwidth(0) - ((s:GitStatus[a:buf]["IsGit"]) ? 69 : 45)))
                            
                                    endif
                            
  900              0.000435     endif
                            
  900              0.001748     return " %<%(" . l:middleText . "%)"

FUNCTION  asyncrun#fullname()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:942
Called 2 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    2              0.000004 	let f = a:f
    2              0.000008 	if f =~ "'."
                            		try
                            			redir => m
                            			silent exe ':marks' f[1]
                            			redir END
                            			let f = split(split(m, '\n')[-1])[-1]
                            			let f = filereadable(f)? f : ''
                            		catch
                            			let f = '%'
                            		endtry
    2              0.000002 	endif
    2              0.000003 	if f == '%'
    1              0.000005 		let f = expand('%')
    1              0.000005 		if &bt == 'terminal'
                            			let f = ''
    1              0.000001 		endif
    2              0.000002 	endif
    2              0.000028 	let f = fnamemodify(f, ':p')
    2              0.000004 	if s:asyncrun_windows
                            		let f = substitute(f, "\\", '/', 'g')
    2              0.000001 	endif
    2              0.000005 	if len(f) > 1
    2              0.000005 		let size = len(f)
    2              0.000007 		if f[size - 1] == '/'
    1              0.000003 			let f = strpart(f, 0, size - 1)
    2              0.000001 		endif
    2              0.000002 	endif
    2              0.000003 	return f

FUNCTION  <SNR>5_GetFilename()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:66
Called 900 times
Total time:   0.019117
 Self time:   0.019117

count  total (s)   self (s)
  900              0.011145     let l:flname = expand("#" . a:buf . ":p")
                                
  900              0.001933     if s:GitStatus[a:buf]["IsGit"]
                                    return fnamemodify(s:GitStatus[a:buf]["RootDir"], ":t") .  substitute(l:flname, s:GitStatus[a:buf]["RootDir"], "", "")
  900              0.000508     endif
                            
  900              0.001145     return l:flname

FUNCTION  <SNR>4_restore_cpo()
    Defined: ~/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim:22
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000026   let &cpo = s:save_cpo
    1              0.000006   unlet s:save_cpo

FUNCTION  <SNR>3_run()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1363
Called 1 time
Total time:   0.001670
 Self time:   0.000471

count  total (s)   self (s)
    1              0.000018 	let l:opts = deepcopy(a:opts)
    1              0.000002 	let l:command = a:opts.cmd
    1              0.000002 	let l:retval = ''
    1              0.000002 	let l:mode = g:asyncrun_mode
    1              0.000002 	let l:runner = ''
    1              0.000002 	let l:opts.origin = l:opts.cmd
                            
    1              0.000002 	if a:opts.mode != ''
                            		let l:mode = a:opts.mode
    1              0.000000 	endif
                            
                            	" mode alias
    1              0.000009 	let l:modemap = {'async':0, 'make':1, 'bang':2, 'python':3, 'os':4, 'hide':5, 'terminal': 6, 'execute':1, 'term':6, 'system':4}
                            
    1              0.000003 	let l:modemap['external'] = 4
    1              0.000003 	let l:modemap['quickfix'] = 0
    1              0.000002 	let l:modemap['vim'] = 2
                            
    1              0.000004 	let l:mode = get(l:modemap, l:mode, l:mode)
                            
                            	" alias "-mode=raw" to "-mode=async -raw=1"
    1              0.000004 	if type(l:mode) == type('') && l:mode == 'raw'
                            		let l:mode = 0
                            		let l:opts.raw = 1
    1              0.000003 	elseif type(l:mode) == 0 && l:mode == 6
                            		let pos = get(l:opts, 'pos', '')
                            		if has_key(g:asyncrun_runner, pos)
                            			let l:runner = pos
                            		elseif pos == 'bang' || pos == 'vim'
                            			let l:mode = 2
                            		elseif pos == 'extern' || pos == 'external'
                            			let l:mode = 4
                            		elseif pos == 'system' || pos == 'os'
                            			let l:mode = 4
                            		elseif pos == 'quickfix'
                            			let l:mode = 0
                            			let l:opts.raw = 1
                            		endif
    1              0.000001 	endif
                            
                            	" process makeprg/grepprg in -program=?
    1              0.000001 	let l:program = ""
                            
    1              0.000002 	let s:async_efm = a:opts.errorformat
                            
    1              0.000002 	if l:opts.program == 'make'
                            		let l:program = &makeprg
    1              0.000001 	elseif l:opts.program == 'grep'
                            		let l:program = &grepprg
                            		let s:async_efm = &grepformat
    1              0.000001 	elseif l:opts.program == 'wsl'
                            		if s:asyncrun_windows != 0
                            			let root = ($SystemRoot == '')? 'C:/Windows' : $SystemRoot
                            			let t1 = root . '/system32/wsl.exe'
                            			let t2 = root . '/sysnative/wsl.exe'
                            			let tt = executable(t1)? t1 : (executable(t2)? t2 : '')
                            			if tt == ''
                            				call s:ErrorMsg("not find wsl in your system")
                            				return
                            			endif
                            			let cmd = s:shellescape(substitute(tt, '\\', '\/', 'g'))
                            			let dist = get(l:opts, 'dist', get(g:, 'asyncrun_dist', ''))
                            			if dist != ''
                            				let cmd = cmd . ' -d ' . dist
                            			endif
                            			let l:command = cmd . ' ' . l:command
                            		else
                            			call s:ErrorMsg("only available for Windows")
                            			return ''
                            		endif
    1              0.000001 	elseif l:opts.program != ''
                            		let name = l:opts.program
                            		let test = ['cygwin', 'msys', 'mingw32', 'mingw64']
                            		if index(test, name) >= 0
                            			unsilent let l:command = s:program_msys(l:opts)
                            		else
                            			if has_key(g:asyncrun_program, name) == 0
                            				call s:ErrorMsg(name . " not found in g:asyncrun_program")
                            				return ''
                            			endif
                            			let F = g:asyncrun_program[name]
                            			if type(F) == type('')
                            				let F = function(F)
                            			endif
                            			unsilent let l:command = F(l:opts)
                            		endif
                            		if l:command == ''
                            			return ''
                            		endif
                            		let l:opts.cmd = l:command
    1              0.000000 	endif
                            
    1              0.000001 	if l:program != ''
                            		if l:program =~# '\$\*'
                            			let l:command = s:StringReplace(l:program, '\$\*', l:command)
                            		elseif l:command != ''
                            			let l:command = l:program . ' ' . l:command
                            		else
                            			let l:command = l:program
                            		endif
                            		let l:command = s:StringStrip(l:command)
                            		let s:async_program_cmd = ''
                            		silent exec 'AsyncRun -program=parse @ '. l:command
                            		let l:command = s:async_program_cmd
    1              0.000001 	endif
                            
    1              0.000013 	if l:command =~ '^\s*$'
                            		echohl ErrorMsg
                            		echom "E471: Command required"
                            		echohl NONE
                            		return
    1              0.000001 	endif
                            
    1              0.000004 	let l:wrapper = get(g:, 'asyncrun_wrapper', '')
                            
    1              0.000002 	if l:wrapper != ''
                            		let l:command = l:wrapper . ' ' . l:command
    1              0.000000 	endif
                            
    1              0.000001 	if l:mode >= 10
                            		let l:opts.cmd = l:command
                            		if g:asyncrun_hook != ''
                            			exec 'call '. g:asyncrun_hook .'(l:opts)'
                            		endif
                            		return ''
    1              0.000002 	elseif l:mode == 7
                            		if s:asyncrun_windows != 0 && s:asyncrun_gui != 0
                            			let l:mode = 4
                            		else
                            			let script = get(g:, 'asyncrun_script', '')
                            			let l:mode = (script == '')? 2 : 4
                            		endif
    1              0.000001 	endif
                            
    1              0.000002 	let g:asyncrun_cmd = l:command
    1   0.000201   0.000008 	let t = s:StringStrip(l:command)
                            
    1              0.000004 	if strpart(t, 0, 1) == ':' && g:asyncrun_strict == 0
                            		exec strpart(t, 1)
                            		return ''
    1              0.000002 	elseif l:runner != ''
                            		let F = g:asyncrun_runner[l:runner]
                            		if type(F) == type('')
                            			let F = function(F)
                            		endif
                            		let obj = deepcopy(l:opts)
                            		let obj.cmd = command
                            		let obj.src = a:opts.cmd
                            		call F(obj)
                            		return ''
    1              0.000001 	endif
                            
    1              0.000004 	if exists('g:asyncrun_open')
                            		let s:asyncrun_open = g:asyncrun_open
                            		if has_key(a:opts, 'open')
                            			let s:asyncrun_open = a:opts.open
                            		endif
                            		if has_key(a:opts, 'silent')
                            			if a:opts.silent
                            				let s:asyncrun_open = 0
                            			endif
                            		endif
    1              0.000000 	endif
                            
    1              0.000002 	if l:mode == 0 && s:asyncrun_support != 0
    1              0.000003 		let s:async_info.postsave = opts.post
    1              0.000002 		let s:async_info.autosave = opts.auto
    1              0.000002 		let s:async_info.text = opts.text
    1              0.000001 		let s:async_info.raw = opts.raw
    1              0.000001 		let s:async_info.range = opts.range
    1              0.000002 		let s:async_info.range_top = opts.range_top
    1              0.000002 		let s:async_info.range_bot = opts.range_bot
    1              0.000002 		let s:async_info.range_buf = opts.range_buf
    1              0.000001 		let s:async_info.strip = opts.strip
    1              0.000001 		let s:async_info.append = opts.append
    1   0.001018   0.000012 		if s:AsyncRun_Job_Start(l:command) != 0
                            			call s:AutoCmd('Error')
    1              0.000000 		endif
                            	elseif l:mode <= 1 && has('quickfix')
                            		call s:AutoCmd('Pre')
                            		call s:AutoCmd('Start')
                            		let l:makesave = &l:makeprg
                            		let l:script = s:ScriptWrite(l:command, 0)
                            		if s:asyncrun_windows != 0
                            			let &l:makeprg = s:shellescape(l:script)
                            		else
                            			let &l:makeprg = 'source '. s:shellescape(l:script)
                            		endif
                            		let l:efm1 = &g:efm
                            		let l:efm2 = &l:efm
                            		if g:asyncrun_local != 0
                            			let &g:efm = s:async_efm
                            			let &l:efm = s:async_efm
                            		endif
                            		if has('autocmd')
                            			call s:AsyncRun_Job_AutoCmd(0, opts.auto)
                            			exec "noautocmd make!"
                            			call s:AsyncRun_Job_AutoCmd(1, opts.auto)
                            		else
                            			exec "make!"
                            		endif
                            		if g:asyncrun_local != 0
                            			if l:efm1 != &g:efm | let &g:efm = l:efm1 | endif
                            			if l:efm2 != &l:efm | let &l:efm = l:efm2 | endif
                            		endif
                            		let &l:makeprg = l:makesave
                            		if s:asyncrun_windows == 0
                            			try | call delete(l:script) | catch | endtry
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            		call s:AutoCmd('Stop')
                            	elseif l:mode <= 2
                            		let autocmd = get(opts, 'autocmd', 0)
                            		if autocmd != 0
                            			call s:AutoCmd('Pre')
                            			call s:AutoCmd('Start')
                            		endif
                            		exec '!'. escape(l:command, '%#')
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            		if autocmd != 0
                            			call s:AutoCmd('Stop')
                            		endif
                            	elseif l:mode == 3
                            		if s:asyncrun_windows == 0
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		elseif has('nvim')
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		elseif has('python3')
                            			let l:script = s:ScriptWrite(l:command, 0)
                            			py3 import subprocess, vim
                            			py3 argv = {'args': vim.eval('l:script'), 'shell': True}
                            			py3 argv['stdout'] = subprocess.PIPE
                            			py3 argv['stderr'] = subprocess.STDOUT
                            			py3 p = subprocess.Popen(**argv)
                            			py3 text = p.stdout.read()
                            			py3 p.stdout.close()
                            			py3 c = p.wait()
                            			if has('patch-7.4.145')
                            				let l:retval = py3eval('text')
                            				let g:asyncrun_shell_error = py3eval('c')
                            			else
                            				py3 text = text.replace('\\', '\\\\').replace('"', '\\"')
                            				py3 text = text.replace('\n', '\\n').replace('\r', '\\r')
                            				py3 vim.command('let l:retval = "%s"'%text)
                            				py3 vim.command('let g:asyncrun_shell_error = %d'%c)
                            			endif
                            		elseif has('python')
                            			let l:script = s:ScriptWrite(l:command, 0)
                            			py import subprocess, vim
                            			py argv = {'args': vim.eval('l:script'), 'shell': True}
                            			py argv['stdout'] = subprocess.PIPE
                            			py argv['stderr'] = subprocess.STDOUT
                            			py p = subprocess.Popen(**argv)
                            			py text = p.stdout.read()
                            			py p.stdout.close()
                            			py c = p.wait()
                            			if has('patch-7.4.145')
                            				let l:retval = pyeval('text')
                            				let g:asyncrun_shell_error = pyeval('c')
                            			else
                            				py text = text.replace('\\', '\\\\').replace('"', '\\"')
                            				py text = text.replace('\n', '\\n').replace('\r', '\\r')
                            				py vim.command('let l:retval = "%s"'%text)
                            				py vim.command('let g:asyncrun_shell_error = %d'%c)
                            			endif
                            		else
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            	elseif l:mode <= 5
                            		let script = get(g:, 'asyncrun_script', '')
                            		if script != '' && l:mode == 4
                            			let $VIM_COMMAND = l:command
                            			let l:command = script . ' ' . l:command
                            			if s:asyncrun_windows
                            				let ccc = s:shellescape(s:ScriptWrite(l:command, 0))
                            				silent exec '!start /b cmd /C '. ccc
                            			else
                            				call system(l:command . ' &')
                            			endif
                            		elseif s:asyncrun_windows
                            			if l:mode == 4
                            				let l:ccc = s:shellescape(s:ScriptWrite(l:command, 1))
                            				silent exec '!start cmd /C '. l:ccc
                            			else
                            				let l:ccc = s:shellescape(s:ScriptWrite(l:command, 0))
                            				silent exec '!start /b cmd /C '. l:ccc
                            			endif
                            			redraw
                            		else
                            			if l:mode == 4
                            				exec '!' . escape(l:command, '%#')
                            			else
                            				call system(l:command . ' &')
                            			endif
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            	elseif l:mode == 6
                            		let opts.cmd = l:command
                            		call s:start_in_terminal(opts)
    1              0.000002 	endif
                            
    1              0.000003 	return l:retval

FUNCTION  asyncrun#get_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1066
Called 1 time
Total time:   0.001050
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000004 	let markers = ['.project', '.git', '.hg', '.svn', '.root']
    1              0.000004 	if exists('g:asyncrun_rootmarks')
                            		let markers = g:asyncrun_rootmarks
    1              0.000001 	endif
    1              0.000002 	if a:0 > 0
                            		if type(a:1) == type([])
                            			let markers = a:1
                            		endif
    1              0.000001 	endif
    1              0.000002 	let strict = (a:0 >= 2)? (a:2) : 0
    1   0.001021   0.000013 	let l:hr = s:find_root(a:path, markers, strict)
    1              0.000002 	if s:asyncrun_windows
                            		let l:hr = s:StringReplace(l:hr, '/', "\\")
    1              0.000000 	endif
    1              0.000001 	return l:hr

FUNCTION  <SNR>3_AutoCmd()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:221
Called 2 times
Total time:   0.000137
 Self time:   0.000076

count  total (s)   self (s)
    2              0.000008 	if has('autocmd') && ((g:asyncrun_skip / 2) % 2) == 0
    2              0.000003 		if g:asyncrun_silent
    2   0.000115   0.000054 			exec 'silent doautocmd User AsyncRun'.a:name
                            		else
                            			exec 'doautocmd User AsyncRun'.a:name
    2              0.000002 		endif
    2              0.000002 	endif

FUNCTION  <SNR>3_ExtractOpt()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:868
Called 1 time
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
    1              0.000004 	let cmd = a:command
    1              0.000002 	let opts = {}
    1              0.000012 	while cmd =~# '^-\%(\w\+\)\%([= ]\|$\)'
                            		let opt = matchstr(cmd, '^-\zs\w\+')
                            		if cmd =~ '^-\w\+='
                            			let val = matchstr(cmd, '^-\w\+=\zs\%(\\.\|\S\)*')
                            		else
                            			let val = (opt == 'cwd')? '' : 1
                            		endif
                            		let opts[opt] = substitute(val, '\\\(\s\)', '\1', 'g')
                            		let cmd = substitute(cmd, '^-\w\+\%(=\%(\\.\|\S\)*\)\=\s*', '', '')
    1              0.000002 	endwhile
    1              0.000196 	let cmd = substitute(cmd, '^\s*\(.\{-}\)\s*$', '\1', '')
    1              0.000013 	let cmd = substitute(cmd, '^@\s*', '', '')
    1              0.000005 	let opts.cwd = get(opts, 'cwd', '')
    1              0.000003 	let opts.mode = get(opts, 'mode', '')
    1              0.000002 	let opts.save = get(opts, 'save', '')
    1              0.000003 	let opts.program = get(opts, 'program', '')
    1              0.000003 	let opts.post = get(opts, 'post', '')
    1              0.000005 	let opts.text = get(opts, 'text', '')
    1              0.000004 	let opts.auto = get(opts, 'auto', '')
    1              0.000005 	let opts.raw = get(opts, 'raw', '')
    1              0.000005 	let opts.strip = get(opts, 'strip', '')
    1              0.000004 	let opts.append = get(opts, 'append', '')
    1              0.000002 	if 0
                            		echom 'cwd:'. opts.cwd
                            		echom 'mode:'. opts.mode
                            		echom 'save:'. opts.save
                            		echom 'program:'. opts.program
                            		echom 'command:'. cmd
    1              0.000001 	endif
    1              0.000004 	return [cmd, opts]

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  900   0.164548   0.041273  SetStatusLine()
  601   0.073757             <SNR>5_ManageWinStl()
  900   0.047550   0.041914  <SNR>5_GitInit()
  900   0.046934   0.027817  <SNR>5_BuildFilenameLbl()
  900   0.028791             <SNR>5_BuildInfBar()
  900   0.019117             <SNR>5_GetFilename()
    1   0.005636   0.000208  <SNR>5_GitUpdate()
    1   0.005428   0.001609  asyncrun#run()
    1   0.001670   0.000471  <SNR>3_run()
    1   0.001050   0.000042  asyncrun#get_root()
    1   0.001008   0.000068  <SNR>3_find_root()
    1   0.001006   0.000844  <SNR>3_AsyncRun_Job_Start()
    1   0.000887   0.000415  <SNR>3_guess_root()
   54   0.000587             <SNR>3_StringReplace()
    2   0.000397             <SNR>3_StringStrip()
    7   0.000392             <SNR>3_path_join()
    1   0.000308             <SNR>3_ExtractOpt()
    2   0.000137   0.000076  <SNR>3_AutoCmd()
    2   0.000133             asyncrun#fullname()
    1   0.000037             <SNR>4_restore_cpo()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  601              0.073757  <SNR>5_ManageWinStl()
  900   0.047550   0.041914  <SNR>5_GitInit()
  900   0.164548   0.041273  SetStatusLine()
  900              0.028791  <SNR>5_BuildInfBar()
  900   0.046934   0.027817  <SNR>5_BuildFilenameLbl()
  900              0.019117  <SNR>5_GetFilename()
    1   0.005428   0.001609  asyncrun#run()
    1   0.001006   0.000844  <SNR>3_AsyncRun_Job_Start()
   54              0.000587  <SNR>3_StringReplace()
    1   0.001670   0.000471  <SNR>3_run()
    1   0.000887   0.000415  <SNR>3_guess_root()
    2              0.000397  <SNR>3_StringStrip()
    7              0.000392  <SNR>3_path_join()
    1              0.000308  <SNR>3_ExtractOpt()
    1   0.005636   0.000208  <SNR>5_GitUpdate()
    2              0.000133  asyncrun#fullname()
    2   0.000137   0.000076  <SNR>3_AutoCmd()
    1   0.001008   0.000068  <SNR>3_find_root()
    1   0.001050   0.000042  asyncrun#get_root()
    1              0.000037  <SNR>4_restore_cpo()

