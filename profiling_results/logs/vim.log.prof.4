FUNCTION  <SNR>6_OnFileTypeSet()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:598
Called 2 times
Total time:   0.015494
 Self time:   0.006868

count  total (s)   self (s)
                              " The contents of the command-line window are empty when the filetype is set
                              " for the first time. Users should never change its filetype so we only rely
                              " on the CmdwinEnter event for that window.
    2              0.000025   if !empty( getcmdwintype() )
                                return
    2              0.000004   endif
                            
    2   0.000438   0.000047   if !s:AllowedToCompleteInCurrentBuffer()
    1              0.000003     return
    1              0.000002   endif
                            
    1   0.000090   0.000029   call s:SetUpCompleteopt()
    1   0.000026   0.000013   call s:SetCompleteFunc()
    1   0.000025   0.000010   call s:StartMessagePoll()
    1   0.000110   0.000038   call s:EnableAutoHover()
                            
    1   0.006585   0.006580   py3 ycm_state.OnFileTypeSet()
    1   0.008162   0.000093   call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>3_find_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1008
Called 3 times
Total time:   0.005437
 Self time:   0.000519

count  total (s)   self (s)
    3              0.000041 	function! s:guess_root(filename, markers)
                            		let fullname = asyncrun#fullname(a:filename)
                            		if fullname =~ '^fugitive:/'
                            			if exists('b:git_dir')
                            				return fnamemodify(b:git_dir, ':h')
                            			endif
                            			return '' " skip any fugitive buffers early
                            		endif
                            		let pivot = fullname
                            		if !isdirectory(pivot)
                            			let pivot = fnamemodify(pivot, ':h')
                            		endif
                            		while 1
                            			let prev = pivot
                            			for marker in a:markers
                            				let newname = s:path_join(pivot, marker)
                            				if newname =~ '[\*\?\[\]]'
                            					if glob(newname) != ''
                            						return pivot
                            					endif
                            				elseif filereadable(newname)
                            					return pivot
                            				elseif isdirectory(newname)
                            					return pivot
                            				endif
                            			endfor
                            			let pivot = fnamemodify(pivot, ':h')
                            			if pivot == prev
                            				break
                            			endif
                            		endwhile
                                    return ''
                            	endfunc
    3              0.000019 	if a:path == '%'
    3              0.000029 		if exists('b:asyncrun_root') && b:asyncrun_root != ''
                            			return b:asyncrun_root
    3              0.000025 		elseif exists('t:asyncrun_root') && t:asyncrun_root != ''
                            			return t:asyncrun_root
    3              0.000019 		elseif exists('g:asyncrun_root') && g:asyncrun_root != ''
                            			return g:asyncrun_root
    3              0.000006 		endif
    3              0.000005 	endif
    3   0.004696   0.000080 	let root = s:guess_root(a:path, a:markers)
    3              0.000009 	if root != ''
    3   0.000351   0.000049 		return asyncrun#fullname(root)
                            	elseif a:strict != 0
                            		return ''
                            	endif
                            	" Not found: return parent directory of current file / file itself.
                            	let fullname = asyncrun#fullname(a:path)
                            	if isdirectory(fullname)
                            		return fullname
                            	endif
                            	return asyncrun#fullname(fnamemodify(fullname, ':h'))

FUNCTION  <SNR>5_GitInit()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:315
Called 485 times
Total time:   0.079237
 Self time:   0.075455

count  total (s)   self (s)
                            
  485              0.005232     if !has_key(s:GitStatus, a:buf)
    1              0.000008         let s:GitStatus[a:buf] = {"LocalEnable" : 1 ,"IsGit": 0, "RootDir": "", "BranchName": "",  "Dirty": "", "IsTracked": 0, "InsertNum": 0, "DeleteNum": 0, "CacheExpired": 0}
  485              0.001083     endif
                            
  485              0.004899     if !s:GitStatus["enabled"] || !s:GitStatus[a:buf]["LocalEnable"]
                                    return
  485              0.000722     endif
                            
  485              0.028956     let l:flname = expand("#" . a:buf . ":p")
                                " If we opened a dir or taglist, ignore.
  485              0.010027     if !filereadable(l:flname)
                                    let s:GitStatus[a:buf]["LocalEnable"] = 0
                                    return
  485              0.000835     endif 
                            
  485              0.003734     if s:GitStatus[a:buf]["CacheExpired"] > 0
                                    " Dont update unless it has been a while
  484              0.004330         let s:GitStatus[a:buf]["CacheExpired"] -= 1
  484              0.001041         return
    1              0.000000     endif
                            
                                " Renew Cache after update
    1              0.000002     let s:GitStatus[a:buf]["CacheExpired"] = s:GitMaxCacheExp
                            
    1   0.003795   0.000013     call s:GitUpdate(1, a:buf)
                            

FUNCTION  <SNR>3_check_quickfix()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:2003
Called 3 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000014 		let height = get(g:, "asyncrun_open", 0)
    3              0.000007 		if exists('s:asyncrun_open')
                            			let height = s:asyncrun_open
    3              0.000003 		endif
                            		" echo 'height: '.height . ' ' .s:asyncrun_open
    3              0.000003 		if height > 0
                            			call asyncrun#quickfix_toggle(height, 1)
    3              0.000000 		endif

FUNCTION  <SNR>3_StringStrip()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:863
Called 6 times
Total time:   0.000961
 Self time:   0.000961

count  total (s)   self (s)
    6              0.000956 	return substitute(a:text, '^\s*\(.\{-}\)\s*$', '\1', '')

FUNCTION  SetTaglistSts()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:167
Called 40 times
Total time:   0.011497
 Self time:   0.003842

count  total (s)   self (s)
   40   0.011380   0.003725     return "%#ErrLbl# " . youcompleteme#GetErrorCount() . " " .  "%#ErrLblSepWrn#" . s:rASym .  "%#WrnLbl# " . youcompleteme#GetWarningCount() . " " .  "%#WrnLblSepClk#" . s:rASym .  "%#ClkLbl#%= " . strftime('%b %d %Y %l:%M %p')

FUNCTION  <SNR>2_Tlist_Window_Mark_File_Window()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:2661
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000012     if getbufvar('%', '&buftype') == '' && !&previewwindow
    1              0.000007         let w:tlist_file_window = "yes"
    1              0.000002     endif

FUNCTION  <SNR>6_ShouldUseSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1029
Called 2 times
Total time:   0.002152
 Self time:   0.002152

count  total (s)   self (s)
    2              0.002148   return py3eval( 'vimsupport.VimSupportsPopupWindows()' )

FUNCTION  <SNR>2_Tlist_Window_Create()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:1355
Called 1 time
Total time:   0.043587
 Self time:   0.024301

count  total (s)   self (s)
    1   0.000086   0.000031     call s:Tlist_Log_Msg('Tlist_Window_Create()')
                                " If the window is open, jump to it
    1              0.000074     let winnum = bufwinnr(g:TagList_title)
    1              0.000004     if winnum != -1
                                    " Jump to the existing window
                                    if winnr() != winnum
                                        exe winnum . 'wincmd w'
                                    endif
                                    return
    1              0.000001     endif
                            
                                " If used with winmanager don't open windows. Winmanager will handle
                                " the window/buffer management
    1              0.000006     if s:tlist_app_name == "winmanager"
                                    return
    1              0.000001     endif
                            
                                " Create a new window. If user prefers a horizontal window, then open
                                " a horizontally split window. Otherwise open a vertically split
                                " window
    1              0.000004     if g:Tlist_Use_Horiz_Window
                                    " Open a horizontally split window
                                    let win_dir = 'botright'
                                    " Horizontal window height
                                    let win_size = g:Tlist_WinHeight
    1              0.000002     else
    1              0.000006         if s:tlist_winsize_chgd == -1
                                        " Open a vertically split window. Increase the window size, if
                                        " needed, to accomodate the new window
    1              0.000013             if g:Tlist_Inc_Winwidth && &columns < (80 + g:Tlist_WinWidth)
                                            " Save the original window position
                                            let s:tlist_pre_winx = getwinposx()
                                            let s:tlist_pre_winy = getwinposy()
                            
                                            " one extra column is needed to include the vertical split
                                            let &columns= &columns + g:Tlist_WinWidth + 1
                            
                                            let s:tlist_winsize_chgd = 1
    1              0.000002             else
    1              0.000006                 let s:tlist_winsize_chgd = 0
    1              0.000002             endif
    1              0.000001         endif
                            
    1              0.000003         if g:Tlist_Use_Right_Window
                                        " Open the window at the rightmost place
                                        let win_dir = 'botright vertical'
    1              0.000002         else
                                        " Open the window at the leftmost place
    1              0.000005             let win_dir = 'topleft vertical'
    1              0.000002         endif
    1              0.000006         let win_size = g:Tlist_WinWidth
    1              0.000002     endif
                            
                                " If the tag listing temporary buffer already exists, then reuse it.
                                " Otherwise create a new buffer
    1              0.000067     let bufnum = bufnr(g:TagList_title)
    1              0.000004     if bufnum == -1
                                    " Create a new buffer
    1              0.000005         let wcmd = g:TagList_title
                                else
                                    " Edit the existing buffer
                                    let wcmd = '+buffer' . bufnum
    1              0.000001     endif
                            
                                " Create the taglist window
                                " Preserve the alternate file
    1              0.000009     let cmd_mod = (v:version >= 700) ? 'keepalt ' : ''
    1   0.003719   0.001327     exe 'silent! ' . cmd_mod . win_dir . ' ' . win_size . 'split ' . wcmd
                            
                                " Save the new window position
    1              0.006773     let s:tlist_winx = getwinposx()
    1              0.015794     let s:tlist_winy = getwinposy()
                            
                                " Initialize the taglist window
    1   0.016894   0.000055     call s:Tlist_Window_Init()

FUNCTION  SetStatusLine()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:139
Called 485 times
Total time:   0.312954
 Self time:   0.071445

count  total (s)   self (s)
  485              0.005672     let l:winnum = win_id2win(a:winid)
  485              0.003180     let l:buf = winbufnr(l:winnum)
  485              0.003917     let l:isActiveWindow = (l:winnum == winnr())
                                
                                " Initialize Git
  485   0.088557   0.009320     call s:GitInit(l:buf)
                            
                                " Mode
  485              0.007024     let l:sts = s:modeMap[l:isActiveWindow][a:nextToTaglist][mode()]
                            
                                " File or function name
  485   0.112175   0.012826     let l:sts .= s:BuildFilenameLbl(l:buf, l:isActiveWindow)
                             
                                " Left align
  485              0.002080     let l:sts .= "%="
                                
                            
                                " Modified flag
  485              0.008164     let l:sts .= s:modifiedFlag[getbufvar(l:buf, "&modified")][l:isActiveWindow]
                              
                                " Information bar
  485   0.073412   0.010489     let l:sts .= s:BuildInfBar(l:buf, l:isActiveWindow)
                            
  485              0.001525     return l:sts

FUNCTION  <SNR>6_EnableAutoHover()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:581
Called 1 time
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    1              0.000006   if g:ycm_auto_hover ==# 'CursorHold' && s:enable_hover
    1              0.000004     augroup YcmBufHover
    1              0.000049       autocmd! * <buffer>
    1              0.000009       autocmd CursorHold <buffer> call s:Hover()
    1              0.000001     augroup END
    1              0.000002   endif

FUNCTION  <SNR>2_Tlist_Window_Display_Help()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:606
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000002     if s:tlist_app_name == "winmanager"
                                    " To handle a bug in the winmanager plugin, add a space at the
                                    " last line
                                    call setline('$', ' ')
    1              0.000001     endif
                            
    1              0.000001     if s:tlist_brief_help
                                    " Add the brief help
    1              0.000013         call append(0, '" Press <F1> to display help text')
                                else
                                    " Add the extensive help
                                    call append(0, '" <enter> : Jump to tag definition')
                                    call append(1, '" o : Jump to tag definition in new window')
                                    call append(2, '" p : Preview the tag definition')
                                    call append(3, '" <space> : Display tag prototype')
                                    call append(4, '" u : Update tag list')
                                    call append(5, '" s : Select sort field')
                                    call append(6, '" d : Remove file from taglist')
                                    call append(7, '" x : Zoom-out/Zoom-in taglist window')
                                    call append(8, '" + : Open a fold')
                                    call append(9, '" - : Close a fold')
                                    call append(10, '" * : Open all folds')
                                    call append(11, '" = : Close all folds')
                                    call append(12, '" [[ : Move to the start of previous file')
                                    call append(13, '" ]] : Move to the start of next file')
                                    call append(14, '" q : Close the taglist window')
                                    call append(15, '" <F1> : Remove help text')
    1              0.000001     endif

FUNCTION  <SNR>6_VisitedBufferRequiresReparse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:470
Called 5 times
Total time:   0.000474
 Self time:   0.000181

count  total (s)   self (s)
    5              0.000064   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
    2              0.000012     return 0
    3              0.000007   endif
                            
    3   0.000360   0.000067   return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  <SNR>6_ReceiveMessages()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:97
Called 6 times
Total time:   0.020230
 Self time:   0.018981

count  total (s)   self (s)
    6              0.000147   let poll_again = v:false
    6   0.001531   0.000282   if s:AllowedToCompleteInCurrentBuffer()
    3              0.018249     let poll_again = py3eval( 'ycm_state.OnPeriodicTick()' )
    6              0.000031   endif
                            
    6              0.000023   if poll_again
    1              0.000040     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    5              0.000011   else
                                " Don't poll again until we open another buffer
    5              0.000039     let s:pollers.receive_messages.id = -1
    6              0.000010   endif

FUNCTION  <SNR>6_SetUpKeyMappings()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:265
Called 1 time
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
                              " The g:ycm_key_select_completion and g:ycm_key_previous_completion used to
                              " exist and are now here purely for the sake of backwards compatibility; we
                              " don't want to break users if we can avoid it.
                            
    1              0.000005   if exists('g:ycm_key_select_completion') && index(g:ycm_key_list_select_completion,       g:ycm_key_select_completion) == -1
                                call add(g:ycm_key_list_select_completion, g:ycm_key_select_completion)
    1              0.000000   endif
                            
    1              0.000003   if exists('g:ycm_key_previous_completion') && index(g:ycm_key_list_previous_completion,       g:ycm_key_previous_completion) == -1
                                call add(g:ycm_key_list_previous_completion, g:ycm_key_previous_completion)
    1              0.000000   endif
                            
    3              0.000006   for key in g:ycm_key_list_select_completion
                                " With this command, when the completion window is visible, the tab key
                                " (default) will select the next candidate in the window. In vim, this also
                                " changes the typed-in text to that of the candidate completion.
    2              0.000023     exe 'inoremap <expr>' . key .  ' pumvisible() ? "\<C-n>" : "\' . key .'"'
    3              0.000003   endfor
                            
    3              0.000003   for key in g:ycm_key_list_previous_completion
                                " This selects the previous candidate for shift-tab (default)
    2              0.000018     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
    3              0.000001   endfor
                            
    2              0.000003   for key in g:ycm_key_list_stop_completion
                                " When selecting a candidate and closing the completion menu with the <C-y>
                                " key, the menu will automatically be reopened because of the TextChangedI
                                " event. We define a command to prevent that.
    1              0.000010     exe 'inoremap <expr>' . key . ' <SID>StopCompletion( "\' . key . '" )'
    2              0.000001   endfor
                            
    1              0.000002   if !empty( g:ycm_key_invoke_completion )
    1              0.000002     let invoke_key = g:ycm_key_invoke_completion
                            
                                " Inside the console, <C-Space> is passed as <Nul> to Vim
    1              0.000001     if invoke_key ==# '<C-Space>'
    1              0.000004       imap <Nul> <C-Space>
    1              0.000001     endif
                            
    1              0.000009     silent! exe 'inoremap <unique> <silent> ' . invoke_key . ' <C-R>=<SID>RequestSemanticCompletion()<CR>'
    1              0.000001   endif
                            
    1              0.000001   if !empty( g:ycm_key_detailed_diagnostics )
    1              0.000012     silent! exe 'nnoremap <unique> ' . g:ycm_key_detailed_diagnostics . ' :YcmShowDetailedDiagnostic<CR>'
    1              0.000001   endif
                            
    1              0.000002   if s:completion_api == s:COMPLETION_COMPLETEFUNC
                                " The TextChangedI event is not triggered when deleting a character while
                                " the completion menu is open. We handle this by closing the completion menu
                                " on the keys that delete a character in insert mode.
                                for key in [ "<BS>", "<C-h>" ]
                                  silent! exe 'inoremap <unique> <expr> ' . key . ' <SID>OnDeleteChar( "\' . key . '" )'
                                endfor
    1              0.000001   endif

FUNCTION  <SNR>2_Tlist_Post_Close_Cleanup()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:1877
Called 1 time
Total time:   0.000299
 Self time:   0.000221

count  total (s)   self (s)
    1   0.000108   0.000030     call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
                                " Mark all the files as not visible
    1              0.000007     let i = 0
    1              0.000009     while i < s:tlist_file_count
                                    let s:tlist_{i}_visible = 0
                                    let i = i + 1
    1              0.000005     endwhile
                            
                                " Remove the taglist autocommands
    1              0.000017     silent! autocmd! TagListAutoCmds
                            
                                " Clear all the highlights
    1              0.000005     match none
                            
    1              0.000010     silent! syntax clear TagListTitle
    1              0.000004     silent! syntax clear TagListComment
    1              0.000003     silent! syntax clear TagListTagScope
                            
                                " Remove the left mouse click mapping if it was setup initially
    1              0.000005     if g:Tlist_Use_SingleClick
                                    if hasmapto('<LeftMouse>')
                                        nunmap <LeftMouse>
                                    endif
    1              0.000002     endif
                            
    1              0.000006     if s:tlist_app_name != "winmanager"
    1              0.000013     if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 || s:tlist_winsize_chgd != 1 || &columns < (80 + g:Tlist_WinWidth)
                                    " No need to adjust window width if using horizontally split taglist
                                    " window or if columns is less than 101 or if the user chose not to
                                    " adjust the window width
                                else
                                    " If the user didn't manually move the window, then restore the window
                                    " position to the pre-taglist position
                                    if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 && getwinposx() == s:tlist_winx && getwinposy() == s:tlist_winy
                                        exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
                                    endif
                            
                                    " Adjust the Vim window width
                                    let &columns= &columns - (g:Tlist_WinWidth + 1)
    1              0.000001     endif
    1              0.000001     endif
                            
    1              0.000011     let s:tlist_winsize_chgd = -1
                            
                                " Reset taglist state variables
    1              0.000005     if s:tlist_app_name == "winmanager"
                                    let s:tlist_app_name = "none"
    1              0.000001     endif
    1              0.000007     let s:tlist_window_initialized = 0

FUNCTION  <SNR>6_SetUpSigns()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:330
Called 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
                              " We try to ensure backwards compatibility with Syntastic if the user has
                              " already defined styling for Syntastic highlight groups.
                            
    1              0.000018   if !hlexists( 'YcmErrorSign' )
    1              0.000002     if hlexists( 'SyntasticErrorSign')
                                  highlight link YcmErrorSign SyntasticErrorSign
    1              0.000001     else
    1              0.000004       highlight link YcmErrorSign error
    1              0.000000     endif
    1              0.000001   endif
                            
    1              0.000002   if !hlexists( 'YcmWarningSign' )
    1              0.000002     if hlexists( 'SyntasticWarningSign')
                                  highlight link YcmWarningSign SyntasticWarningSign
    1              0.000001     else
    1              0.000003       highlight link YcmWarningSign todo
    1              0.000000     endif
    1              0.000000   endif
                            
    1              0.000002   if !hlexists( 'YcmErrorLine' )
    1              0.000002     highlight link YcmErrorLine SyntasticErrorLine
    1              0.000001   endif
                            
    1              0.000002   if !hlexists( 'YcmWarningLine' )
    1              0.000002     highlight link YcmWarningLine SyntasticWarningLine
    1              0.000000   endif
                            
    1              0.000007   exe 'sign define YcmError text=' . g:ycm_error_symbol . ' texthl=YcmErrorSign linehl=YcmErrorLine'
    1              0.000004   exe 'sign define YcmWarning text=' . g:ycm_warning_symbol . ' texthl=YcmWarningSign linehl=YcmWarningLine'
                            

FUNCTION  <SNR>2_Tlist_Refresh()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:2909
Called 4 times
Total time:   0.001113
 Self time:   0.000639

count  total (s)   self (s)
    4   0.000393   0.000139     call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' . s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
                                " If we are entering the buffer from one of the taglist functions, then
                                " no need to refresh the taglist window again.
    4              0.000016     if s:Tlist_Skip_Refresh
                                    " We still need to update the taglist menu
                                    if g:Tlist_Show_Menu
                                        call s:Tlist_Menu_Update_File(0)
                                    endif
                                    return
    4              0.000008     endif
                            
                                " If part of the winmanager plugin and not configured to process
                                " tags always and not configured to display the tags menu, then return
    4              0.000040     if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
                                    return
    4              0.000006     endif
                            
                                " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    4              0.000018     if &buftype != ''
    2              0.000005         return
    2              0.000003     endif
                            
    2              0.000167     let filename = fnamemodify(bufname('%'), ':p')
    2   0.000246   0.000051     let ftype = s:Tlist_Get_Buffer_Filetype('%')
                            
                                " If the file doesn't support tag listing, skip it
    2   0.000066   0.000041     if s:Tlist_Skip_File(filename, ftype)
    2              0.000004         return
                                endif
                            
                                let tlist_win = bufwinnr(g:TagList_title)
                            
                                " If the taglist window is not opened and not configured to process
                                " tags always and not displaying the tags menu, then return
                                if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
                                    return
                                endif
                            
                                let fidx = s:Tlist_Get_File_Index(filename)
                                if fidx == -1
                                    " Check whether this file is removed based on user request
                                    " If it is, then don't display the tags for this file
                                    if s:Tlist_User_Removed_File(filename)
                                        return
                                    endif
                            
                                    " If the taglist should not be auto updated, then return
                                    if !g:Tlist_Auto_Update
                                        return
                                    endif
                                endif
                            
                                let cur_lnum = line('.')
                            
                                if fidx == -1
                                    " Update the tags for the file
                                    let fidx = s:Tlist_Process_File(filename, ftype)
                                else
                                    let mtime = getftime(filename)
                                    if s:tlist_{fidx}_mtime != mtime
                                        " Invalidate the tags listed for this file
                                        let s:tlist_{fidx}_valid = 0
                            
                                        " Update the taglist and the window
                                        call Tlist_Update_File(filename, ftype)
                            
                                        " Store the new file modification time
                                        let s:tlist_{fidx}_mtime = mtime
                                    endif
                                endif
                            
                                " Update the taglist window
                                if tlist_win != -1
                                    " Disable screen updates
                                    let old_lazyredraw = &lazyredraw
                                    set nolazyredraw
                            
                                    " Save the current window number
                                    let save_winnr = winnr()
                            
                                    " Goto the taglist window
                                    call s:Tlist_Window_Goto_Window()
                            
                                    if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
                                        " Save the cursor position
                                        let save_line = line('.')
                                        let save_col = col('.')
                                    endif
                            
                                    " Update the taglist window
                                    call s:Tlist_Window_Refresh_File(filename, ftype)
                            
                                    " Open the fold for the file
                                    exe "silent! " . s:tlist_{fidx}_start . "," . s:tlist_{fidx}_end . "foldopen!"
                            
                                    if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
                                        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
                                            " If displaying tags for only one file in the taglist
                                            " window and about to display the tags for a new file,
                                            " then center the current tag line for the new file
                                            let center_tag_line = 1
                                        else
                                            let center_tag_line = 0
                                        endif
                            
                                        " Highlight the current tag
                                        call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
                                    else
                                        " Restore the cursor position
                                        if v:version >= 601
                                            call cursor(save_line, save_col)
                                        else
                                            exe save_line
                                            exe 'normal! ' . save_col . '|'
                                        endif
                                    endif
                            
                                    " Jump back to the original window
                                    if save_winnr != winnr()
                                        call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
                                    endif
                            
                                    " Restore screen updates
                                    let &lazyredraw = old_lazyredraw
                                endif
                            
                                " Update the taglist menu
                                if g:Tlist_Show_Menu
                                    call s:Tlist_Menu_Update_File(0)
                                endif

FUNCTION  <SNR>6_OnCursorMovedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:788
Called 167 times
Total time:   0.025896
 Self time:   0.006670

count  total (s)   self (s)
  167   0.024478   0.005252   if !s:AllowedToCompleteInCurrentBuffer()
  164              0.000436     return
    3              0.000005   endif
                            
    3              0.000419   py3 ycm_state.OnCursorMoved()

FUNCTION  <SNR>4_restore_cpo()
    Defined: ~/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim:22
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000010   let &cpo = s:save_cpo
    1              0.000003   unlet s:save_cpo

FUNCTION  <SNR>6_DisableOnLargeFile()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:414
Called 9 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
    9              0.000128   if exists( 'b:ycm_largefile' )
    7              0.000032     return b:ycm_largefile
    2              0.000003   endif
                            
    2              0.000015   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
    2              0.000082   let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
    2              0.000008   if b:ycm_largefile
                                py3 vimsupport.PostVimMessage( 'YouCompleteMe is disabled in this buffer;' + ' the file exceeded the max size (see YCM options).' )
    2              0.000003   endif
    2              0.000008   return b:ycm_largefile

FUNCTION  <SNR>6_SetUpSyntaxHighlighting()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:366
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                              " We try to ensure backwards compatibility with Syntastic if the user has
                              " already defined styling for Syntastic highlight groups.
                            
    1              0.000002   if !hlexists( 'YcmErrorSection' )
                                if hlexists( 'SyntasticError' )
                                  highlight link YcmErrorSection SyntasticError
                                else
                                  highlight link YcmErrorSection SpellBad
                                endif
    1              0.000000   endif
                            
    1              0.000002   if !hlexists( 'YcmWarningSection' )
                                if hlexists( 'SyntasticWarning' )
                                  highlight link YcmWarningSection SyntasticWarning
                                else
                                  highlight link YcmWarningSection SpellCap
                                endif
    1              0.000000   endif

FUNCTION  <SNR>3_AsyncRun_Job_Update()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:386
Called 6 times
Total time:   0.002471
 Self time:   0.002304

count  total (s)   self (s)
    6              0.000061 	let l:iconv = (g:asyncrun_encs != "")? 1 : 0
    6              0.000022 	let l:count = 0
    6              0.000016 	let l:total = 0
    6              0.000044 	let l:empty = [{'text':''}]
    6   0.000361   0.000194 	let l:check = s:AsyncRun_Job_CheckScroll()
    6              0.000088 	let l:efm1 = &g:efm
    6              0.000060 	let l:efm2 = &l:efm
    6              0.000025 	if g:asyncrun_encs == &encoding
                            		let l:iconv = 0
    6              0.000009 	endif
    6              0.000021 	if g:asyncrun_local != 0
    6              0.000143 		let &l:efm = s:async_info.errorformat
    6              0.000093 		let &g:efm = s:async_info.errorformat
    6              0.000011 	endif
    6              0.000079 	let l:raw = (&efm == '')? 1 : 0
    6              0.000029 	if s:async_info.raw == 1
                            		let l:raw = 1
    6              0.000010 	endif
    6              0.000044 	while s:async_tail < s:async_head
                            		let l:text = s:async_output[s:async_tail]
                            		if l:iconv != 0
                            			try
                            				let l:text = iconv(l:text, g:asyncrun_encs, &encoding)
                            			catch /.*/
                            			endtry
                            		endif
                            		let l:text = substitute(l:text, '\r$', '', 'g')
                            		if l:text != ''
                            			if l:raw == 0
                            				if and(g:asyncrun_skip, 1) == 0
                            					caddexpr l:text
                            				else
                            					noautocmd caddexpr l:text
                            				endif
                            			else
                            				call setqflist([{'text':l:text}], 'a')
                            			endif
                            		elseif g:asyncrun_trim == 0
                            			call setqflist(l:empty, 'a')
                            		endif
                            		let l:total += 1
                            		unlet s:async_output[s:async_tail]
                            		let s:async_tail += 1
                            		let l:count += 1
                            		if a:count > 0 && l:count >= a:count
                            			break
                            		endif
    6              0.000028 	endwhile
    6              0.000027 	if g:asyncrun_local != 0
    6              0.000118 		if l:efm1 != &g:efm | let &g:efm = l:efm1 | endif
    6              0.000174 		if l:efm2 != &l:efm | let &l:efm = l:efm2 | endif
    6              0.000010 	endif
    6              0.000049 	if s:async_scroll != 0 && l:total > 0 && l:check != 0
                            		call s:AsyncRun_Job_AutoScroll()
    6              0.000013 	endif
    6              0.000031 	return l:count

FUNCTION  youcompleteme#EnableCursorMovedAutocommands()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:183
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000003   augroup ycmcompletemecursormove
    1              0.000002     autocmd!
    1              0.000009     autocmd CursorMoved * call s:OnCursorMovedNormalMode()
    1              0.000006     autocmd TextChanged * call s:OnTextChangedNormalMode()
    1              0.000005     autocmd TextChangedI * call s:OnTextChangedInsertMode( v:false )
    1              0.000002     if s:completion_api == s:COMPLETION_TEXTCHANGEDP
    1              0.000005       autocmd TextChangedP * call s:OnTextChangedInsertMode( v:true )
    1              0.000000     endif
    1              0.000005     autocmd InsertCharPre * call s:OnInsertChar()
    1              0.000001   augroup END

FUNCTION  <SNR>3_AsyncRun_Job_OnFinish()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:507
Called 3 times
Total time:   0.017263
 Self time:   0.014827

count  total (s)   self (s)
                            	" caddexpr '(OnFinish): '.a:what.' '.s:async_state
    3              0.000028 	if s:async_state == 0
                            		return -1
    3              0.000005 	endif
    3              0.000024 	if exists('s:async_job')
    3              0.000047 		unlet s:async_job
    3              0.000007 	endif
    3              0.000017 	if exists('s:async_timer')
    3              0.000029 		call timer_stop(s:async_timer)
    3              0.000011 		unlet s:async_timer
    3              0.000005 	endif
    3   0.001251   0.000077 	call s:AsyncRun_Job_Update(-1)
    3              0.000023 	let l:current = localtime()
    3              0.000031 	let l:last = l:current - s:async_start
    3   0.000128   0.000071 	let l:check = s:AsyncRun_Job_CheckScroll()
    3              0.000009 	if s:async_code == 0
    3              0.000025 		let l:text = "[Finished in ".l:last." seconds]"
    3              0.000012 		if !s:async_info.strip
    3              0.000048 			call setqflist([{'text':l:text}], 'a')
    3              0.000006 		endif
    3              0.000011 		let g:asyncrun_status = "success"
                            	else
                            		let l:text = 'with code '.s:async_code
                            		let l:text = "[Finished in ".l:last." seconds ".l:text."]"
                            		call setqflist([{'text':l:text}], 'a')
                            		let g:asyncrun_status = "failure"
    3              0.000003 	endif
    3              0.000012 	let s:async_state = 0
    3              0.000013 	if s:async_scroll != 0 && l:check != 0
    3   0.000146   0.000064 		call s:AsyncRun_Job_AutoScroll()
    3              0.000003 	endif
    3              0.000012 	let g:asyncrun_code = s:async_code
    3              0.000015 	let g:asyncrun_name = ''
    3              0.000008 	if g:asyncrun_bell != 0
                            		exec "norm! \<esc>"
    3              0.000004 	endif
    3              0.000011 	if s:async_info.post != ''
    3   0.000867   0.000086 		exec s:async_info.post
    3              0.000013 		let s:async_info.post = ''
    3              0.000005 	endif
    3              0.000011 	if g:asyncrun_exit != ""
                            		exec g:asyncrun_exit
    3              0.000004 	endif
    3   0.000184   0.000062 	call s:AsyncRun_Job_AutoCmd(1, s:async_info.auto)
    3   0.000260   0.000040 	call s:AutoCmd('Stop')
    3              0.013844 	redrawstatus!
    3              0.000023 	redraw

FUNCTION  <SNR>3_AutoCmd()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:221
Called 9 times
Total time:   0.000633
 Self time:   0.000421

count  total (s)   self (s)
    9              0.000044 	if has('autocmd') && ((g:asyncrun_skip / 2) % 2) == 0
    9              0.000014 		if g:asyncrun_silent
    9   0.000484   0.000272 			exec 'silent doautocmd User AsyncRun'.a:name
                            		else
                            			exec 'doautocmd User AsyncRun'.a:name
    9              0.000010 		endif
    9              0.000006 	endif

FUNCTION  <SNR>2_Tlist_Window_Toggle()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:2725
Called 1 time
Total time:   0.044783
 Self time:   0.000226

count  total (s)   self (s)
    1   0.000108   0.000029     call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
                                " If taglist window is open then close it.
    1              0.000129     let winnum = bufwinnr(g:TagList_title)
    1              0.000006     if winnum != -1
                                    call s:Tlist_Window_Close()
                                    return
    1              0.000002     endif
                            
    1   0.044487   0.000026     call s:Tlist_Window_Open()
                            
                                " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
                                " set
    1              0.000002     if !g:Tlist_GainFocus_On_ToggleOpen
    1   0.000023   0.000006         call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
    1              0.000001     endif
                            
                                " Update the taglist menu
    1              0.000001     if g:Tlist_Show_Menu
                                    call s:Tlist_Menu_Update_File(0)
    1              0.000001     endif

FUNCTION  <SNR>6_StartMessagePoll()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:88
Called 6 times
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
    6              0.000056   if s:pollers.receive_messages.id < 0
    5              0.000156     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    6              0.000015   endif

FUNCTION  <SNR>6_UpdateMatches()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:657
Called 37 times
Total time:   0.007933
 Self time:   0.007933

count  total (s)   self (s)
   37              0.007867   py3 ycm_state.UpdateMatches()

FUNCTION  <SNR>3_StringReplace()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:857
Called 162 times
Total time:   0.001252
 Self time:   0.001252

count  total (s)   self (s)
  162              0.000865 	let l:data = split(a:text, a:old, 1)
  162              0.000339 	return join(l:data, a:new)

FUNCTION  <SNR>3_AsyncRun_Job_AutoCmd()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:446
Called 6 times
Total time:   0.000203
 Self time:   0.000203

count  total (s)   self (s)
    6              0.000049 	if !has('autocmd') | return | endif
    6              0.000029 	let name = (a:auto == '')? g:asyncrun_auto : a:auto
    6              0.000096 	if name !~ '^\w\+$' || name == 'NONE' || name == '<NONE>'
    6              0.000010 		return
                            	endif
                            	if ((g:asyncrun_skip / 4) % 2) != 0
                            		return 0
                            	endif
                            	if a:mode == 0
                            		if g:asyncrun_silent
                            			silent exec 'doautocmd QuickFixCmdPre '. name
                            		else
                            			exec 'doautocmd QuickFixCmdPre '. name
                            		endif
                            	else
                            		if g:asyncrun_silent
                            			silent exec 'doautocmd QuickFixCmdPost '. name
                            		else
                            			exec 'doautocmd QuickFixCmdPost '. name
                            		endif
                            	endif

FUNCTION  <SNR>3_guess_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1009
Called 1 time
Total time:   0.002042
 Self time:   0.000875

count  total (s)   self (s)
    1   0.000240   0.000026 		let fullname = asyncrun#fullname(a:filename)
    1              0.000013 		if fullname =~ '^fugitive:/'
                            			if exists('b:git_dir')
                            				return fnamemodify(b:git_dir, ':h')
                            			endif
                            			return '' " skip any fugitive buffers early
    1              0.000002 		endif
    1              0.000004 		let pivot = fullname
    1              0.000013 		if !isdirectory(pivot)
    1              0.000009 			let pivot = fnamemodify(pivot, ':h')
    1              0.000002 		endif
    2              0.000008 		while 1
    2              0.000009 			let prev = pivot
    8              0.000035 			for marker in a:markers
    7   0.001091   0.000138 				let newname = s:path_join(pivot, marker)
    7              0.000211 				if newname =~ '[\*\?\[\]]'
                            					if glob(newname) != ''
                            						return pivot
                            					endif
    7              0.000128 				elseif filereadable(newname)
                            					return pivot
    7              0.000065 				elseif isdirectory(newname)
    1              0.000003 					return pivot
    6              0.000010 				endif
    7              0.000016 			endfor
    1              0.000009 			let pivot = fnamemodify(pivot, ':h')
    1              0.000004 			if pivot == prev
                            				break
    1              0.000002 			endif
    1              0.000003 		endwhile
                                    return ''

FUNCTION  youcompleteme#GetWarningCount()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:207
Called 40 times
Total time:   0.002885
 Self time:   0.002885

count  total (s)   self (s)
   40              0.002824   return py3eval( 'ycm_state.GetWarningCount()' )

FUNCTION  <SNR>2_Tlist_Window_Refresh()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:1798
Called 1 time
Total time:   0.000278
 Self time:   0.000195

count  total (s)   self (s)
    1   0.000024   0.000006     call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
                                " Set report option to a huge value to prevent informational messages
                                " while deleting the lines
    1              0.000004     let old_report = &report
    1              0.000005     set report=99999
                            
                                " Mark the buffer as modifiable
    1              0.000004     setlocal modifiable
                            
                                " Delete the contents of the buffer to the black-hole register
    1              0.000003     silent! %delete _
                            
                                " As we have cleared the taglist window, mark all the files
                                " as not visible
    1              0.000002     let i = 0
    1              0.000002     while i < s:tlist_file_count
                                    let s:tlist_{i}_visible = 0
                                    let i = i + 1
    1              0.000001     endwhile
                            
    1              0.000001     if g:Tlist_Compact_Format == 0
                                    " Display help in non-compact mode
    1   0.000071   0.000028         call s:Tlist_Window_Display_Help()
    1              0.000000     endif
                            
                                " Mark the buffer as not modifiable
    1              0.000003     setlocal nomodifiable
                            
                                " Restore the report option
    1              0.000003     let &report = old_report
                            
                                " If the tags for only one file should be displayed in the taglist
                                " window, then no need to add the tags here. The bufenter autocommand
                                " will add the tags for that file.
    1              0.000002     if g:Tlist_Show_One_File
                                    return
    1              0.000000     endif
                            
                                " List all the tags for the previously processed files
                                " Do this only if taglist is configured to display tags for more than
                                " one file. Otherwise, when Tlist_Show_One_File is configured,
                                " tags for the wrong file will be displayed.
    1              0.000001     let i = 0
    1              0.000002     while i < s:tlist_file_count
                                    call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename, s:tlist_{i}_filetype)
                                    let i = i + 1
    1              0.000001     endwhile
                            
    1              0.000001     if g:Tlist_Auto_Update
                                    " Add and list the tags for all buffers in the Vim buffer list
    1              0.000001         let i = 1
    1              0.000003         let last_bufnum = bufnr('$')
    3              0.000005         while i <= last_bufnum
    2              0.000004             if buflisted(i)
    1              0.000024                 let fname = fnamemodify(bufname(i), ':p')
    1   0.000028   0.000012                 let ftype = s:Tlist_Get_Buffer_Filetype(i)
                                            " If the file doesn't support tag listing, skip it
    1   0.000015   0.000009                 if !s:Tlist_Skip_File(fname, ftype)
                                                call s:Tlist_Window_Refresh_File(fname, ftype)
    1              0.000001                 endif
    2              0.000000             endif
    2              0.000003             let i = i + 1
    3              0.000003         endwhile
    1              0.000000     endif
                            
                                " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
    1              0.000001     if g:Tlist_File_Fold_Auto_Close
                                    " Close all the folds
                                    silent! %foldclose
    1              0.000001     endif
                            
                                " Move the cursor to the top of the taglist window
    1              0.000012     normal! gg

FUNCTION  <SNR>6_SetUpPython()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:212
Called 1 time
Total time:   0.089684
 Self time:   0.089684

count  total (s)   self (s)
    1              0.000001   py3 << EOF
                            import os.path as p
                            import sys
                            import traceback
                            import vim
                            
                            root_folder = p.normpath( p.join( vim.eval( 's:script_folder_path' ), '..' ) )
                            third_party_folder = p.join( root_folder, 'third_party' )
                            
                            # Add dependencies to Python path.
                            dependencies = [ p.join( root_folder, 'python' ),
                                             p.join( third_party_folder, 'requests-futures' ),
                                             p.join( third_party_folder, 'ycmd' ),
                                             p.join( third_party_folder, 'requests_deps', 'idna' ),
                                             p.join( third_party_folder, 'requests_deps', 'chardet' ),
                                             p.join( third_party_folder,
                                                     'requests_deps',
                                                     'urllib3',
                                                     'src' ),
                                             p.join( third_party_folder, 'requests_deps', 'certifi' ),
                                             p.join( third_party_folder, 'requests_deps', 'requests' ) ]
                            
                            sys.path[ 0:0 ] = dependencies
                            
                            # We enclose this code in a try/except block to avoid backtraces in Vim.
                            try:
                              # Import the modules used in this file.
                              from ycm import base, vimsupport, youcompleteme
                            
                              if 'ycm_state' in globals():
                                # If re-initializing, pretend that we shut down
                                ycm_state.OnVimLeave()
                                del ycm_state
                            
                              ycm_state = youcompleteme.YouCompleteMe()
                            except Exception as error:
                              # We don't use PostVimMessage or EchoText from the vimsupport module because
                              # importing this module may fail.
                              vim.command( 'redraw | echohl WarningMsg' )
                              for line in traceback.format_exc().splitlines():
                                vim.command( "echom '{0}'".format( line.replace( "'", "''" ) ) )
                            
                              vim.command( "echo 'YouCompleteMe unavailable: {0}'"
                                           .format( str( error ).replace( "'", "''" ) ) )
                              vim.command( 'echohl None' )
                              vim.command( 'return 0' )
                            else:
                              vim.command( 'return 1' )
                            EOF

FUNCTION  <SNR>3_path_join()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:975
Called 21 times
Total time:   0.002115
 Self time:   0.002115

count  total (s)   self (s)
   21              0.000126     let l:size = strlen(a:home)
   21              0.000142     if l:size == 0 | return a:name | endif
   21              0.000152     let l:last = strpart(a:home, l:size - 1, 1)
   21              0.000372     if has("win32") || has("win64") || has("win16") || has('win95')
                            		let l:first = strpart(a:name, 0, 1)
                            		if l:first == "/" || l:first == "\\"
                            			let head = strpart(a:home, 1, 2)
                            			if index([":\\", ":/"], head) >= 0
                            				return strpart(a:home, 0, 2) . a:name
                            			endif
                            			return a:name
                            		elseif index([":\\", ":/"], strpart(a:name, 1, 2)) >= 0
                            			return a:name
                            		endif
                                    if l:last == "/" || l:last == "\\"
                                        return a:home . a:name
                                    else
                                        return a:home . '/' . a:name
                                    endif
   21              0.000031     else
   21              0.000101 		if strpart(a:name, 0, 1) == "/"
                            			return a:name
   21              0.000032 		endif
   21              0.000050         if l:last == "/"
                                        return a:home . a:name
   21              0.000028         else
   21              0.000089             return a:home . '/' . a:name
                                    endif
                                endif

FUNCTION  <SNR>5_GitUpdate()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:275
Called 3 times
Total time:   0.022925
 Self time:   0.000890

count  total (s)   self (s)
    3              0.000062     let l:buf = get(a:, 1, bufnr())
                            
    3              0.000034     if !s:GitStatus["enabled"] || !s:GitStatus[l:buf]["LocalEnable"]
                                    return
    3              0.000006     endif
                                
    3              0.000132     let l:flname = expand("#" . l:buf . ":p")
    3              0.000031     let l:parentDir = fnamemodify(l:flname, ":h")
    3              0.000121     let l:tmpfile = tempname()
    3              0.000017     let l:redir = l:tmpfile ." 2> /dev/null "
    3              0.000031     let l:isFullUpdate = a:initOrWrite || !s:GitStatus[l:buf]["IsGit"]
    3              0.000009     let l:cmd = ""
                            
    3              0.000009     if l:isFullUpdate
    1              0.000017         let l:cmd  = "git -C " . l:parentDir . " rev-parse --absolute-git-dir > " . l:redir . "&& "
    1              0.000003         let l:cmd .= "(git -C " . l:parentDir . " symbolic-ref HEAD || " 
    1              0.000003         let l:cmd .= "git -C " . l:parentDir . " rev-parse --short HEAD) >> " . l:redir . "&& "
    3              0.000005     endif
                            
    3              0.000056     let l:cmd .= "([[ -n $(git -C " . l:parentDir . " ls-files " . l:flname . ") ]] && " .  "echo '1'  || echo '0') >> " . l:redir . "&& "
    3              0.000034     let l:cmd .= "([[ -z $(git -C " . l:parentDir . " status -s) ]] || echo '*') >> " . l:redir . "&& "
    3              0.000040     let l:cmd .= "git -C " . l:parentDir . " diff --numstat -- " . l:flname . " >> " . l:redir
                                
    3              0.000013     if g:asyncrun_status != "running"
                                    " Async call to g:AsyncGitCallback()
    3   0.022188   0.000153         call asyncrun#run("",  {"post": "call g:AsyncGitCallback(" . l:isFullUpdate . ", '" . l:tmpfile . "', " .  l:buf . ")"}, l:cmd)
                                else
                                    " If we could not execute it now, void the cache so that it is executed
                                    " the next time 
                                    let s:GitStatus[l:buf]["CacheExpired"] = 0
    3              0.000004     endif

FUNCTION  <SNR>2_Tlist_Skip_File()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:880
Called 3 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
                                " Skip buffers with no names and buffers with filetype not set
    3              0.000016     if a:filename == '' || a:ftype == ''
    3              0.000006         return 1
                                endif
                            
                                " Skip files which are not supported by exuberant ctags
                                " First check whether default settings for this filetype are available.
                                " If it is not available, then check whether user specified settings are
                                " available. If both are not available, then don't list the tags for this
                                " filetype
                                let var = 's:tlist_def_' . a:ftype . '_settings'
                                if !exists(var)
                                    let var = 'g:tlist_' . a:ftype . '_settings'
                                    if !exists(var)
                                        return 1
                                    endif
                                endif
                            
                                " Skip files which are not readable or files which are not yet stored
                                " to the disk
                                if !filereadable(a:filename)
                                    return 1
                                endif
                            
                                return 0

FUNCTION  <SNR>2_Tlist_Get_File_Index()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:776
Called 5 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    5              0.000018     if s:tlist_file_count == 0 || a:fname == ''
    5              0.000010         return -1
                                endif
                            
                                " If the new filename is same as the last accessed filename, then
                                " return that index
                                if s:tlist_file_name_idx_cache != -1 && s:tlist_file_name_idx_cache < s:tlist_file_count
                                    if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
                                        " Same as the last accessed file
                                        return s:tlist_file_name_idx_cache
                                    endif
                                endif
                            
                                " First, check whether the filename is present
                                let s_fname = a:fname . "\n"
                                let i = stridx(s:tlist_file_names, s_fname)
                                if i == -1
                                    let s:tlist_file_name_idx_cache = -1
                                    return -1
                                endif
                            
                                " Second, compute the file name index
                                let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
                                let s:tlist_file_name_idx_cache = strlen(nl_txt)
                                return s:tlist_file_name_idx_cache

FUNCTION  youcompleteme#GetErrorCount()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:202
Called 40 times
Total time:   0.004770
 Self time:   0.004770

count  total (s)   self (s)
   40              0.004705   return py3eval( 'ycm_state.GetErrorCount()' )

FUNCTION  <SNR>6_OnBufferUnload()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:645
Called 2 times
Total time:   0.007898
 Self time:   0.007462

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
    2              0.000046   let buffer_number = str2nr( expand( '<abuf>' ) )
    2   0.000523   0.000087   if !s:AllowedToCompleteInBuffer( buffer_number )
    1              0.000002     return
    1              0.000001   endif
                            
    1              0.007307   py3 ycm_state.OnBufferUnload( vimsupport.GetIntValue( 'buffer_number' ) )

FUNCTION  <SNR>2_Tlist_Window_Open()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:2669
Called 2 times
Total time:   0.046114
 Self time:   0.000530

count  total (s)   self (s)
    2   0.000188   0.000048     call s:Tlist_Log_Msg('Tlist_Window_Open()')
                                " If the window is open, jump to it
    2              0.000147     let winnum = bufwinnr(g:TagList_title)
    2              0.000011     if winnum != -1
                                    " Jump to the existing window
    1              0.000007         if winnr() != winnum
    1   0.001439   0.000035             exe winnum . 'wincmd w'
    1              0.000003         endif
    1              0.000002         return
    1              0.000002     endif
                            
    1              0.000006     if s:tlist_app_name == "winmanager"
                                    " Taglist plugin is no longer part of the winmanager app
                                    let s:tlist_app_name = "none"
    1              0.000002     endif
                            
                                " Get the filename and filetype for the specified buffer
    1              0.000069     let curbuf_name = fnamemodify(bufname('%'), ':p')
    1   0.000170   0.000066     let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
    1              0.000008     let cur_lnum = line('.')
                            
                                " Mark the current window as the desired window to open a file when a tag
                                " is selected.
    1   0.000048   0.000024     call s:Tlist_Window_Mark_File_Window()
                            
                                " Open the taglist window
    1   0.043607   0.000020     call s:Tlist_Window_Create()
                            
    1   0.000292   0.000014     call s:Tlist_Window_Refresh()
                            
    1              0.000001     if g:Tlist_Show_One_File
                                    " Add only the current buffer and file
                                    "
                                    " If the file doesn't support tag listing, skip it
                                    if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
                                        call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
                                    endif
    1              0.000001     endif
                            
    1              0.000001     if g:Tlist_File_Fold_Auto_Close
                                    " Open the fold for the current file, as all the folds in
                                    " the taglist window are closed
                                    let fidx = s:Tlist_Get_File_Index(curbuf_name)
                                    if fidx != -1
                                        exe "silent! " . s:tlist_{fidx}_start . "," . s:tlist_{fidx}_end . "foldopen!"
                                    endif
    1              0.000000     endif
                            
                                " Highlight the current tag
    1   0.000057   0.000010     call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)

FUNCTION  <SNR>6_PollFileParseResponse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:702
Called 82 times
Total time:   0.037194
 Self time:   0.037194

count  total (s)   self (s)
   82              0.017056   if !py3eval( "ycm_state.FileParseRequestReady()" )
   81              0.003767     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
   81              0.000425     return
    1              0.000003   endif
                            
    1              0.015046   py3 ycm_state.HandleFileParseRequest()
    1              0.000174   if py3eval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
    1              0.000004   endif

FUNCTION  <SNR>6_AllowedToCompleteInBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:438
Called 187 times
Total time:   0.016593
 Self time:   0.015814

count  total (s)   self (s)
  187              0.004864   let buftype = getbufvar( a:buffer, '&buftype' )
                            
  187              0.001968   if has_key( s:buftype_blacklist, buftype )
                                return 0
  187              0.000565   endif
                            
  187              0.001975   let filetype = getbufvar( a:buffer, '&filetype' )
                            
  187   0.002658   0.002340   if empty( filetype ) || s:DisableOnLargeFile( a:buffer )
  178              0.000600     return 0
    9              0.000018   endif
                            
    9              0.000282   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( filetype, '\.' ) )
    9   0.000852   0.000391   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !s:HasAnyKey( g:ycm_filetype_blacklist, split( filetype, '\.' ) )
                            
    9              0.000063   let allowed = whitelist_allows && blacklist_allows
    9              0.000028   if allowed
    9              0.000117     let s:previous_allowed_buffer_number = bufnr( a:buffer )
    9              0.000018   endif
    9              0.000028   return allowed

FUNCTION  <SNR>3_AsyncRun_Job_OnExit()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:580
Called 3 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
                            	" caddexpr "[exit]: ".a:message." ".type(a:message)
    3              0.000025 	let s:async_code = a:message
    3              0.000019 	let s:async_state = or(s:async_state, 2)

FUNCTION  <SNR>2_Tlist_Window_Highlight_Tag()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:3818
Called 1 time
Total time:   0.000047
 Self time:   0.000043

count  total (s)   self (s)
                                " Highlight the current tag only if the user configured the
                                " taglist plugin to do so or if the user explictly invoked the
                                " command to highlight the current tag.
    1              0.000002     if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
                                    return
    1              0.000000     endif
                            
    1              0.000001     if a:filename == ''
                                    return
    1              0.000000     endif
                            
                                " Make sure the taglist window is present
    1              0.000017     let winnum = bufwinnr(g:TagList_title)
    1              0.000001     if winnum == -1
                                    call s:Tlist_Warning_Msg('Error: Taglist window is not open')
                                    return
    1              0.000000     endif
                            
    1   0.000015   0.000011     let fidx = s:Tlist_Get_File_Index(a:filename)
    1              0.000001     if fidx == -1
    1              0.000001         return
                                endif
                            
                                " If the file is currently not displayed in the taglist window, then retrn
                                if !s:tlist_{fidx}_visible
                                    return
                                endif
                            
                                " If there are no tags for this file, then no need to proceed further
                                if s:tlist_{fidx}_tag_count == 0
                                    return
                                endif
                            
                                " Ignore all autocommands
                                let old_ei = &eventignore
                                set eventignore=all
                            
                                " Save the original window number
                                let org_winnr = winnr()
                            
                                if org_winnr == winnum
                                    let in_taglist_window = 1
                                else
                                    let in_taglist_window = 0
                                endif
                            
                                " Go to the taglist window
                                if !in_taglist_window
                                    exe winnum . 'wincmd w'
                                endif
                            
                                " Clear previously selected name
                                match none
                            
                                let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
                                if tidx == -1
                                    " Make sure the current tag line is visible in the taglist window.
                                    " Calling the winline() function makes the line visible.  Don't know
                                    " of a better way to achieve this.
                                    let lnum = line('.')
                            
                                    if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
                                        " Move the cursor to the beginning of the file
                                        exe s:tlist_{fidx}_start
                                    endif
                            
                                    if foldclosed('.') != -1
                                        .foldopen
                                    endif
                            
                                    call winline()
                            
                                    if !in_taglist_window
                                        exe org_winnr . 'wincmd w'
                                    endif
                            
                                    " Restore the autocommands
                                    let &eventignore = old_ei
                                    return
                                endif
                            
                                " Extract the tag type
                                let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
                            
                                " Compute the line number
                                " Start of file + Start of tag type + offset
                                let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset + s:tlist_{fidx}_{tidx}_ttype_idx
                            
                                " Goto the line containing the tag
                                exe lnum
                            
                                " Open the fold
                                if foldclosed('.') != -1
                                    .foldopen
                                endif
                            
                                if a:center
                                    " Move the tag line to the center of the taglist window
                                    normal! z.
                                else
                                    " Make sure the current tag line is visible in the taglist window.
                                    " Calling the winline() function makes the line visible.  Don't know
                                    " of a better way to achieve this.
                                    call winline()
                                endif
                            
                                " Highlight the tag name
                                call s:Tlist_Window_Highlight_Line()
                            
                                " Go back to the original window
                                if !in_taglist_window
                                    exe org_winnr . 'wincmd w'
                                endif
                            
                                " Restore the autocommands
                                let &eventignore = old_ei
                                return

FUNCTION  <SNR>5_GetFilename()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:66
Called 485 times
Total time:   0.045179
 Self time:   0.045179

count  total (s)   self (s)
  485              0.018615     let l:flname = expand("#" . a:buf . ":p")
                                
  485              0.003139     if s:GitStatus[a:buf]["IsGit"]
  481              0.021870         return fnamemodify(s:GitStatus[a:buf]["RootDir"], ":t") .  substitute(l:flname, s:GitStatus[a:buf]["RootDir"], "", "")
    4              0.000004     endif
                            
    4              0.000004     return l:flname

FUNCTION  <SNR>6_HasAnyKey()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:429
Called 9 times
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
   18              0.000112   for key in a:keys
    9              0.000083     if has_key( a:dict, key )
                                  return 1
    9              0.000020     endif
   18              0.000055   endfor
    9              0.000031   return 0

FUNCTION  <SNR>6_OnInsertLeave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:868
Called 2 times
Total time:   0.000388
 Self time:   0.000128

count  total (s)   self (s)
    2   0.000376   0.000116   if !s:AllowedToCompleteInCurrentBuffer()
    2              0.000005     return
                              endif
                            
                              let s:last_char_inserted_by_user = v:false
                            
                              call s:StopPoller( s:pollers.completion )
                              let s:force_semantic = 0
                              let s:completion = s:default_completion
                            
                              call s:OnFileReadyToParse()
                              py3 ycm_state.OnInsertLeave()
                              if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif
                            
                              call s:ClearSignatureHelp()

FUNCTION  youcompleteme#Enable()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:129
Called 1 time
Total time:   0.090451
 Self time:   0.000190

count  total (s)   self (s)
    1   0.000026   0.000008   call s:SetUpBackwardsCompatibility()
                            
    1   0.089696   0.000012   if !s:SetUpPython()
                                return
    1              0.000001   endif
                            
    1   0.000549   0.000030   call s:SetUpOptions()
                            
    1   0.000049   0.000009   call youcompleteme#EnableCursorMovedAutocommands()
    1              0.000001   augroup youcompleteme
    1              0.000002     autocmd!
                                " Note that these events will NOT trigger for the file vim is started with;
                                " so if you do "vim foo.cc", these events will not trigger when that buffer
                                " is read. This is because youcompleteme#Enable() is called on VimEnter and
                                " that happens *after* FileType has already triggered for the initial file.
                                " We don't parse the buffer on the BufRead event since it would only be
                                " useful if the buffer filetype is set (we ignore the buffer if there is no
                                " filetype) and if so, the FileType event has triggered before and thus the
                                " buffer is already parsed.
    1              0.000006     autocmd BufWritePost,FileWritePost * call s:OnFileSave()
    1              0.000005     autocmd FileType * call s:OnFileTypeSet()
    1              0.000006     autocmd BufEnter,CmdwinEnter * call s:OnBufferEnter()
    1              0.000004     autocmd BufUnload * call s:OnBufferUnload()
    1              0.000005     autocmd InsertLeave * call s:OnInsertLeave()
    1              0.000004     autocmd VimLeave * call s:OnVimLeave()
    1              0.000002     autocmd CompleteDone * call s:OnCompleteDone()
    1              0.000002     if exists( '##CompleteChanged' )
    1              0.000006       autocmd CompleteChanged * call s:OnCompleteChanged()
    1              0.000000     endif
    1              0.000006     autocmd BufEnter,WinEnter * call s:UpdateMatches()
    1              0.000001   augroup END
                            
                              " The FileType event is not triggered for the first loaded file. We wait until
                              " the server is ready to manually run the s:OnFileTypeSet function.
    1              0.000011   let s:pollers.server_ready.id = timer_start( s:pollers.server_ready.wait_milliseconds, function( 's:PollServerReady' ) )
                            
    1              0.000037   let s:default_completion = py3eval( 'vimsupport.NO_COMPLETIONS' )
    1              0.000002   let s:completion = s:default_completion
                            
    1              0.000003   if exists( '*prop_type_add' ) && exists( '*prop_type_delete' )
    1              0.000004     hi default YCMInverse term=reverse cterm=reverse gui=reverse
    1              0.000003     call prop_type_delete( 'YCM-signature-help-current-argument' )
    1              0.000006     call prop_type_add( 'YCM-signature-help-current-argument', {   'highlight': 'YCMInverse',   'combine':   1,   'priority':  50, } )
    1              0.000000   endif

FUNCTION  <SNR>3_ExtractOpt()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:868
Called 3 times
Total time:   0.001080
 Self time:   0.001080

count  total (s)   self (s)
    3              0.000021 	let cmd = a:command
    3              0.000011 	let opts = {}
    3              0.000053 	while cmd =~# '^-\%(\w\+\)\%([= ]\|$\)'
                            		let opt = matchstr(cmd, '^-\zs\w\+')
                            		if cmd =~ '^-\w\+='
                            			let val = matchstr(cmd, '^-\w\+=\zs\%(\\.\|\S\)*')
                            		else
                            			let val = (opt == 'cwd')? '' : 1
                            		endif
                            		let opts[opt] = substitute(val, '\\\(\s\)', '\1', 'g')
                            		let cmd = substitute(cmd, '^-\w\+\%(=\%(\\.\|\S\)*\)\=\s*', '', '')
    3              0.000010 	endwhile
    3              0.000627 	let cmd = substitute(cmd, '^\s*\(.\{-}\)\s*$', '\1', '')
    3              0.000040 	let cmd = substitute(cmd, '^@\s*', '', '')
    3              0.000023 	let opts.cwd = get(opts, 'cwd', '')
    3              0.000017 	let opts.mode = get(opts, 'mode', '')
    3              0.000013 	let opts.save = get(opts, 'save', '')
    3              0.000016 	let opts.program = get(opts, 'program', '')
    3              0.000016 	let opts.post = get(opts, 'post', '')
    3              0.000013 	let opts.text = get(opts, 'text', '')
    3              0.000013 	let opts.auto = get(opts, 'auto', '')
    3              0.000013 	let opts.raw = get(opts, 'raw', '')
    3              0.000015 	let opts.strip = get(opts, 'strip', '')
    3              0.000015 	let opts.append = get(opts, 'append', '')
    3              0.000007 	if 0
                            		echom 'cwd:'. opts.cwd
                            		echom 'mode:'. opts.mode
                            		echom 'save:'. opts.save
                            		echom 'program:'. opts.program
                            		echom 'command:'. cmd
    3              0.000005 	endif
    3              0.000013 	return [cmd, opts]

FUNCTION  <SNR>6_OnTextChangedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:797
Called 3 times
Total time:   0.004903
 Self time:   0.000138

count  total (s)   self (s)
    3   0.000496   0.000106   if !s:AllowedToCompleteInCurrentBuffer()
    2              0.000004     return
    1              0.000002   endif
                            
    1   0.004395   0.000020   call s:OnFileReadyToParse()

FUNCTION  <SNR>6_OnFileReadyToParse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:680
Called 2 times
Total time:   0.012444
 Self time:   0.009717

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    2              0.000029   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    2              0.000140   if force_parsing || py3eval( "ycm_state.NeedsReparse()" )
                                " We switched buffers or somethuing, so claer.
                                " FIXME: sig hekp should be buffer local?
    2   0.002729   0.000068     call s:ClearSignatureHelp()
    2              0.009211     py3 ycm_state.OnFileReadyToParse()
                            
    2   0.000214   0.000148     call s:StopPoller( s:pollers.file_parse_response )
    2              0.000073     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    2              0.000008   endif

FUNCTION  asyncrun#fullname()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:942
Called 6 times
Total time:   0.000813
 Self time:   0.000813

count  total (s)   self (s)
    6              0.000038 	let f = a:f
    6              0.000061 	if f =~ "'."
                            		try
                            			redir => m
                            			silent exe ':marks' f[1]
                            			redir END
                            			let f = split(split(m, '\n')[-1])[-1]
                            			let f = filereadable(f)? f : ''
                            		catch
                            			let f = '%'
                            		endtry
    6              0.000008 	endif
    6              0.000015 	if f == '%'
    3              0.000020 		let f = expand('%')
    3              0.000048 		if &bt == 'terminal'
                            			let f = ''
    3              0.000005 		endif
    6              0.000008 	endif
    6              0.000155 	let f = fnamemodify(f, ':p')
    6              0.000025 	if s:asyncrun_windows
                            		let f = substitute(f, "\\", '/', 'g')
    6              0.000008 	endif
    6              0.000027 	if len(f) > 1
    6              0.000027 		let size = len(f)
    6              0.000040 		if f[size - 1] == '/'
    3              0.000018 			let f = strpart(f, 0, size - 1)
    6              0.000008 		endif
    6              0.000010 	endif
    6              0.000017 	return f

FUNCTION  <SNR>6_SetUpCpoptions()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:479
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                              " Without this flag in cpoptions, critical YCM mappings do not work. There's
                              " no way to not have this and have YCM working, so force the flag.
    1              0.000012   set cpoptions+=B
                            
                              " This prevents the display of "Pattern not found" & similar messages during
                              " completion.
    1              0.000005   set shortmess+=c

FUNCTION  <SNR>6_PollServerReady()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:662
Called 2 times
Total time:   0.114561
 Self time:   0.114402

count  total (s)   self (s)
    2              0.000423   if !py3eval( 'ycm_state.IsServerAlive()' )
                                py3 ycm_state.NotifyUserIfServerCrashed()
                                " Server crashed. Don't poll it again.
                                return
    2              0.000004   endif
                            
    2              0.113832   if !py3eval( 'ycm_state.CheckIfServerIsReady()' )
    1              0.000025     let s:pollers.server_ready.id = timer_start( s:pollers.server_ready.wait_milliseconds, function( 's:PollServerReady' ) )
    1              0.000002     return
    1              0.000003   endif
                            
    1   0.000207   0.000048   call s:OnFileTypeSet()

FUNCTION  AsyncRun_Job_OnTimer()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:471
Called 3 times
Total time:   0.019152
 Self time:   0.000592

count  total (s)   self (s)
    3              0.000092 	let limit = (g:asyncrun_timer < 10)? 10 : g:asyncrun_timer
                            	" check on command line window
    3              0.000056 	if &ft == 'vim' && &buftype == 'nofile'
                            		return
    3              0.000007 	endif
    3              0.000014 	if s:async_nvim == 0
    3              0.000027 		if exists('s:async_job')
    3              0.000035 			call job_status(s:async_job)
    3              0.000005 		endif
    3              0.000004 	endif
    3   0.001391   0.000094 	call s:AsyncRun_Job_Update(limit)
    3              0.000028 	if and(s:async_state, 7) == 7
    3              0.000016 		if s:async_head == s:async_tail
    3   0.017405   0.000142 			call s:AsyncRun_Job_OnFinish()
    3              0.000007 		endif
    3              0.000003 	endif

FUNCTION  <SNR>2_Tlist_Buffer_Removed()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:4346
Called 1 time
Total time:   0.000077
 Self time:   0.000040

count  total (s)   self (s)
    1   0.000045   0.000015     call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')
                            
                                " Make sure a valid filename is supplied
    1              0.000003     if a:filename == ''
                                    return
    1              0.000001     endif
                            
                                " Get tag list index of the specified file
    1   0.000019   0.000012     let fidx = s:Tlist_Get_File_Index(a:filename)
    1              0.000002     if fidx == -1
                                    " File not present in the taglist
    1              0.000001         return
                                endif
                            
                                " Remove the file from the list
                                call s:Tlist_Remove_File(fidx, 0)

FUNCTION  <SNR>6_AllowedToCompleteInCurrentBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:465
Called 183 times
Total time:   0.021809
 Self time:   0.005700

count  total (s)   self (s)
  183   0.021570   0.005461   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  asyncrun#run()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1689
Called 3 times
Total time:   0.022035
 Self time:   0.004477

count  total (s)   self (s)
    3              0.000013 	let l:macros = {}
    3              0.000115 	let l:macros['VIM_FILEPATH'] = expand("%:p")
    3              0.000025 	let l:macros['VIM_FILENAME'] = expand("%:t")
    3              0.000082 	let l:macros['VIM_FILEDIR'] = expand("%:p:h")
    3              0.000022 	let l:macros['VIM_FILENOEXT'] = expand("%:t:r")
    3              0.000081 	let l:macros['VIM_PATHNOEXT'] = expand("%:p:r")
    3              0.000025 	let l:macros['VIM_FILEEXT'] = "." . expand("%:e")
    3              0.000021 	let l:macros['VIM_FILETYPE'] = (&filetype)
    3              0.000031 	let l:macros['VIM_CWD'] = getcwd()
    3              0.000020 	let l:macros['VIM_RELDIR'] = expand("%:h:.")
    3              0.000088 	let l:macros['VIM_RELNAME'] = expand("%:p:.")
    3              0.000031 	let l:macros['VIM_CWORD'] = expand("<cword>")
    3              0.000027 	let l:macros['VIM_CFILE'] = expand("<cfile>")
    3              0.000020 	let l:macros['VIM_CLINE'] = line('.')
    3              0.000023 	let l:macros['VIM_VERSION'] = ''.v:version
    3              0.000019 	let l:macros['VIM_SVRNAME'] = v:servername
    3              0.000019 	let l:macros['VIM_COLUMNS'] = ''.&columns
    3              0.000015 	let l:macros['VIM_LINES'] = ''.&lines
    3              0.000049 	let l:macros['VIM_GUI'] = has('gui_running')? 1 : 0
    3   0.005822   0.000079 	let l:macros['VIM_ROOT'] = asyncrun#get_root('%')
    3              0.000135     let l:macros['VIM_HOME'] = expand(split(&rtp, ',')[0])
    3              0.000034 	let l:macros['VIM_PRONAME'] = fnamemodify(l:macros['VIM_ROOT'], ':t')
    3              0.000025 	let l:macros['VIM_DIRNAME'] = fnamemodify(l:macros['VIM_CWD'], ':t')
    3              0.000014 	let l:macros['VIM_PWD'] = l:macros['VIM_CWD']
    3              0.000014 	let l:macros['<cwd>'] = l:macros['VIM_CWD']
    3              0.000016 	let l:macros['<root>'] = l:macros['VIM_ROOT']
    3              0.000013 	let l:macros['<pwd>'] = l:macros['VIM_PWD']
    3              0.000009 	let l:retval = ''
                            
                            	" handle: empty extension
    3              0.000019 	if expand("%:e") == ''
                            		let l:macros['VIM_FILEEXT'] = ''
    3              0.000004 	endif
                            
                            	" extract options
    3   0.001887   0.000123 	let [l:command, l:opts] = s:ExtractOpt(s:StringStrip(a:args))
                            
                            	" check lazy load
    3              0.000018 	if get(l:opts, 'mode', '') == 'load'
                            		return ''
    3              0.000003 	endif
                            
                            	" combine options
    3              0.000025 	if type(a:opts) == type({})
    6              0.000041 		for [l:key, l:val] in items(a:opts)
    3              0.000019 			let l:opts[l:key] = l:val
    6              0.000012 		endfor
    3              0.000005 	endif
                            
                            	" parse makeprg/grepprg and return
    3              0.000011 	if l:opts.program == 'parse'
                            		let s:async_program_cmd = l:command
                            		return s:async_program_cmd
    3              0.000004 	endif
                            
                            	" update marcros
    3              0.000022 	let l:macros['VIM_RUNNAME'] = get(l:opts, 'name', '')
                            
                            	" update info (current running command text)
    3              0.000014 	let g:asyncrun_info = a:args
                            
                            	" setup range
    3              0.000012 	let l:opts.range = 0
    3              0.000009 	let l:opts.range_top = 0
    3              0.000009 	let l:opts.range_bot = 0
    3              0.000008 	let l:opts.range_buf = 0
                            
    3              0.000009 	if a:0 >= 3
                            		if a:1 > 0 && a:2 <= a:3
                            			let l:opts.range = 2
                            			let l:opts.range_top = a:2
                            			let l:opts.range_bot = a:3
                            			let l:opts.range_buf = bufnr('%')
                            		endif
    3              0.000005 	endif
                            
                            	" check cwd
    3              0.000010 	if l:opts.cwd != ''
                            		for [l:key, l:val] in items(l:macros)
                            			let l:replace = (l:key[0] != '<')? '$('.l:key.')' : l:key
                            			let l:opts.cwd = s:StringReplace(l:opts.cwd, l:replace, l:val)
                            		endfor
                            		let l:opts.savecwd = getcwd()
                            		silent! call s:chdir(l:opts.cwd)
                            		let l:macros['VIM_CWD'] = getcwd()
                            		let l:macros['VIM_RELDIR'] = expand("%:h:.")
                            		let l:macros['VIM_RELNAME'] = expand("%:p:.")
                            		let l:macros['VIM_CFILE'] = expand("<cfile>")
                            		let l:macros['VIM_DIRNAME'] = fnamemodify(l:macros['VIM_CWD'], ':t')
                            		let l:macros['<cwd>'] = l:macros['VIM_CWD']
    3              0.000004 	endif
                            
                            	" windows can use $(WSL_XXX)
    3              0.000009 	if s:asyncrun_windows != 0
                            		let wslnames = ['FILEPATH', 'FILENAME', 'FILEDIR', 'FILENOEXT']
                            		let wslnames += ['PATHNOEXT', 'FILEEXT', 'FILETYPE', 'RELDIR']
                            		let wslnames += ['RELNAME', 'CFILE', 'ROOT', 'HOME', 'CWD']
                            		for name in wslnames
                            			let src = l:macros['VIM_' . name]
                            			let l:macros['WSL_' . name] = asyncrun#path_win2unix(src, '/mnt')
                            		endfor
    3              0.000004 	endif
                            
                            	" replace macros and setup environment variables
   84              0.000188 	for [l:key, l:val] in items(l:macros)
   81              0.000275 		let l:replace = (l:key[0] != '<')? '$('.l:key.')' : l:key
   81              0.000111 		if l:key[0] != '<'
   72              0.000139 			if strpart(l:key, 0, 4) != 'WSL_'
   72              0.000324 				exec 'let $'.l:key.' = l:val'
   72              0.000049 			endif
   81              0.000039 		endif
   81   0.001327   0.000574 		let l:command = s:StringReplace(l:command, l:replace, l:val)
   81   0.001055   0.000556 		let l:opts.text = s:StringReplace(l:opts.text, l:replace, l:val)
   84              0.000073 	endfor
                            
                            	" config
    3              0.000007 	let l:opts.cmd = l:command
    3              0.000005 	let l:opts.macros = l:macros
    3              0.000009 	let l:opts.mode = get(l:opts, 'mode', g:asyncrun_mode)
    3              0.000012 	let l:opts.errorformat = get(l:opts, 'errorformat', &errorformat)
    3              0.000009 	let s:async_scroll = (a:bang == '!')? 0 : 1
                            
                            	" check if need to save
    3              0.000007 	let l:save = get(l:opts, 'save', '')
                            
    3              0.000003 	if l:save == ''
    3              0.000007 		let l:save = ''. g:asyncrun_save
    3              0.000001 	endif
                            
    3              0.000003 	if l:save == '1'
                            		silent! update
    3              0.000003 	elseif l:save
                            		silent! wall
    3              0.000002 	endif
                            
                            	" run command
    3   0.008887   0.000088 	let l:retval = s:run(l:opts)
                            
                            	" restore cwd
    3              0.000006 	if l:opts.cwd != ''
                            		silent! call s:chdir(l:opts.savecwd)
    3              0.000002 	endif
                            
    3              0.000007 	return l:retval

FUNCTION  <SNR>5_BuildInfBar()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:105
Called 485 times
Total time:   0.062923
 Self time:   0.062923

count  total (s)   self (s)
  485              0.003686     let l:infBHighlight = (a:isActiveWindow)? "InfB" : "DisInfB"
  485              0.003644     let l:infBar = s:lASym . "%#" . l:infBHighlight . "# "
                            
  485              0.002730     if s:GitStatus[a:buf]["IsGit"]
  481              0.006800         let l:infBar .= s:gitBranchSym . " " .  s:GitStatus[a:buf]["BranchName"] . s:GitStatus[a:buf]["Dirty"]
                            
  481              0.005170         let l:infBar .= "%#" . l:infBHighlight . "Strick#" .  s:sepASym . "  %#" . l:infBHighlight . "#"
                                    
  481              0.002611         if s:GitStatus[a:buf]["IsTracked"]
  481              0.005108             let l:infBar .= s:gitInsSym . " " . s:GitStatus[a:buf]["InsertNum"] . " "
  481              0.004411             let l:infBar .= s:gitDelSym . " " . s:GitStatus[a:buf]["DeleteNum"]
                                    else
                                        let l:infBar .= s:gitUnTckSym
  481              0.000769         endif
                            
  481              0.004781         let l:infBar .= "%#" . l:infBHighlight . "Strick#" .  s:sepASym . "  %#" . l:infBHighlight . "#"
                            
  485              0.000797     endif
                              
  485              0.005881     let l:infBar .= s:cnumSym . " %c" . "%#" . l:infBHighlight .  "Strick#" . s:sepASym . "  %#" . l:infBHighlight . "#"
                            
  485              0.002617     let l:infBar .= s:lnumSym . " %l"
  485              0.004212     let l:infBar .= " %#RCSep" . l:infBHighlight . "#" .  s:sepBSym . "  %#RC#%2P "
                            
  485              0.001729     return l:infBar

FUNCTION  <SNR>2_Tlist_Get_Buffer_Filetype()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:1066
Called 4 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
    4              0.000053     let buf_ft = getbufvar(a:bnum, '&filetype')
                            
                                " Check whether 'filetype' contains multiple file types separated by '.'
                                " If it is, then use the first file type
    4              0.000036     if buf_ft =~ '\.'
                                    let buf_ft = matchstr(buf_ft, '[^.]\+')
    4              0.000006     endif
                            
    4              0.000063     if bufloaded(a:bnum)
                                    " For loaded buffers, the 'filetype' is already determined
    1              0.000002         return buf_ft
    3              0.000004     endif
                            
                                " For unloaded buffers, if the 'filetype' option is set, return it
    3              0.000010     if buf_ft != ''
                                    return buf_ft
    3              0.000005     endif
                            
                                " Skip non-existent buffers
    3              0.000044     if !bufexists(a:bnum)
    3              0.000009         return ''
                                endif
                            
                                " For buffers whose filetype is not yet determined, try to determine
                                " the filetype
                                let bname = bufname(a:bnum)
                            
                                return s:Tlist_Detect_Filetype(bname)

FUNCTION  <SNR>5_BuildFilenameLbl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:79
Called 485 times
Total time:   0.099349
 Self time:   0.047540

count  total (s)   self (s)
  485              0.008139     let l:bufreadonly = getbufvar(a:buf, "&readonly") ||  (getbufvar(a:buf, "&modifiable") == 0)
                            
  485   0.057158   0.011979     let l:middleText = "%#FlnLbl#" . s:GetFilename(a:buf)  . " " .  ((l:bufreadonly) ? s:readonlySym . " " : "")
                            
  485              0.002794     let l:md = mode()
  485              0.003454     if (l:md ==? "i" || l:md ==# "R") && (a:isActiveWindow)
                                    " Consult Taglist about nearby tag
    3   0.006683   0.000053         let l:funcProto = Tlist_Get_Tag_Prototype_By_Line()
                            
    3              0.000011         if (len(l:funcProto))
                                        " Show function name instead in insert or replace mode
                                        let l:middleText = "%#FuncLbl#" . s:tagNameSym .  " " . s:RightTruncate(l:funcProto,  (winwidth(0) - ((s:GitStatus[a:buf]["IsGit"]) ? 69 : 45)))
                            
    3              0.000004         endif
                            
  485              0.000772     endif
                            
  485              0.002886     return " %<%(" . l:middleText . "%)"

FUNCTION  <SNR>6_SetCompleteFunc()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:516
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000005   if s:completion_api == s:COMPLETION_COMPLETEFUNC
                                let &completefunc = 'youcompleteme#CompleteFunc'
    1              0.000001   endif
    1              0.000004   let b:ycm_completing = 1

FUNCTION  <SNR>2_Tlist_Exe_Cmd_No_Acmds()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:871
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000002     let old_eventignore = &eventignore
    1              0.000004     set eventignore=all
    1              0.000006     exe a:cmd
    1              0.000003     let &eventignore = old_eventignore

FUNCTION  <SNR>3_AsyncRun_Job_AutoScroll()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:346
Called 3 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    3              0.000010 	if s:async_quick == 0
                            		if &buftype == 'quickfix'
                            			silent exec 'normal! G'
                            		endif
    3              0.000004 	else
    3              0.000010 		cbottom
    3              0.000005 	endif

FUNCTION  <SNR>6_StopPoller()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:524
Called 9 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    9              0.000069   call timer_stop( a:poller.id )
    9              0.000049   let a:poller.id = -1

FUNCTION  <SNR>3_AsyncRun_Job_CheckScroll()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:357
Called 9 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
    9              0.000045 	if g:asyncrun_last == 0
    9              0.000044 		if &buftype == 'quickfix'
                            			return (line('.') == line('$'))
    9              0.000014 		else
    9              0.000025 			return 1
                            		endif
                            	elseif g:asyncrun_last == 1
                            		let s:async_check_last = 1
                            		let l:winnr = winnr()
                            		" Execute AsyncRun_Job_Cursor() in quickfix
                            		let l:quickfixwinnr = bufwinnr("[Quickfix List]")
                            		if l:quickfixwinnr != -1  " -1 mean the buffer has no window or do not exists
                            			noautocmd exec '' . l:quickfixwinnr . 'windo call s:AsyncRun_Job_Cursor()'
                            		endif
                            		noautocmd silent! exec ''.l:winnr.'wincmd w'
                            		return s:async_check_last
                            	elseif g:asyncrun_last == 2
                            		return 1
                            	else
                            		if &buftype == 'quickfix'
                            			return (line('.') == line('$'))
                            		else
                            			return (!pumvisible())
                            		endif
                            	endif

FUNCTION  asyncrun#get_root()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1066
Called 3 times
Total time:   0.005743
 Self time:   0.000306

count  total (s)   self (s)
    3              0.000037 	let markers = ['.project', '.git', '.hg', '.svn', '.root']
    3              0.000025 	if exists('g:asyncrun_rootmarks')
                            		let markers = g:asyncrun_rootmarks
    3              0.000006 	endif
    3              0.000013 	if a:0 > 0
                            		if type(a:1) == type([])
                            			let markers = a:1
                            		endif
    3              0.000006 	endif
    3              0.000019 	let strict = (a:0 >= 2)? (a:2) : 0
    3   0.005518   0.000081 	let l:hr = s:find_root(a:path, markers, strict)
    3              0.000010 	if s:asyncrun_windows
                            		let l:hr = s:StringReplace(l:hr, '/', "\\")
    3              0.000004 	endif
    3              0.000009 	return l:hr

FUNCTION  <SNR>6_OnVimLeave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:530
Called 1 time
Total time:   0.005447
 Self time:   0.005427

count  total (s)   self (s)
                              " Workaround a NeoVim issue - not shutting down timers correctly
                              " https://github.com/neovim/neovim/issues/6840
    6              0.000015   for poller in values( s:pollers )
    5   0.000044   0.000024     call s:StopPoller( poller )
    6              0.000007   endfor
    1              0.005372   py3 ycm_state.OnVimLeave()

FUNCTION  <SNR>6_SetUpCompleteopt()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:490
Called 2 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    2              0.000020   set completeopt-=menu
    2              0.000008   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    2              0.000007   set completeopt-=longest
                            
    2              0.000015   if g:ycm_add_preview_to_completeopt ==# 'popup' && exists( '*popup_open' )
                                set completeopt+=popup
    2              0.000006   elseif g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
    2              0.000003   endif

FUNCTION  <SNR>3_AsyncRun_Job_OnClose()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:558
Called 3 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
                            	" caddexpr "[close]"
    3              0.000027 	let s:async_debug = 1
    3              0.000007 	let l:limit = 128
    3              0.000012 	let l:options = {'timeout':0}
    3              0.000021 	while ch_status(a:channel) == 'buffered'
                            		let l:text = ch_read(a:channel, l:options)
                            		if l:text == '' " important when child process is killed
                            			let l:limit -= 1
                            			if l:limit < 0 | break | endif
                            		else
                            			call s:AsyncRun_Job_OnCallback(a:channel, l:text)
                            		endif
    3              0.000006 	endwhile
    3              0.000007 	let s:async_debug = 0
    3              0.000010 	if exists('s:async_job')
    3              0.000023 		call job_status(s:async_job)
    3              0.000001 	endif
    3              0.000009 	let s:async_state = or(s:async_state, 4)

FUNCTION  <SNR>6_OnBufferEnter()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:629
Called 5 times
Total time:   0.001042
 Self time:   0.000329

count  total (s)   self (s)
    5   0.000340   0.000101   call s:StartMessagePoll()
    5   0.000679   0.000205   if !s:VisitedBufferRequiresReparse()
    5              0.000013     return
                              endif
                            
                              call s:SetUpCompleteopt()
                              call s:SetCompleteFunc()
                            
                              py3 ycm_state.OnBufferVisit()
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
                              call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>5_ManageWinStl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:176
Called 35 times
Total time:   0.040995
 Self time:   0.040995

count  total (s)   self (s)
   35              0.000846     let l:bottomRightWin = winnr('$')
   35              0.000224     let l:taglistWin = -1
                            
  236              0.001203     for n in range(1, bottomRightWin)
  201              0.001460         let l:wintype = win_gettype(n)
                            
                                    " Ignore popup & autocmd
  201              0.001175         if (l:wintype !=# 'popup' || l:wintype !=# 'autocmd')
  201              0.001227             let l:bufnum = winbufnr(n)
  201              0.001616             let l:winbufname = bufname(l:bufnum)
  201              0.001137             let l:winid = win_getid(n)
  201              0.002536             let l:isPrv = getwinvar(n, "&pvw")
  201              0.007339             let l:isHelp = getbufvar(l:winbufname, "&ft") ==# "help"
  201              0.001852             let l:isQf = getwinvar(n, '&syntax') == 'qf'
                            
  201              0.001083             if l:winbufname ==# g:TagList_title
                                            " Set the taglist status line
   33              0.000736                 call setwinvar(n, '&statusline', "%!SetTaglistSts()")
   33              0.000168                 let l:taglistWin = n
                            
  168              0.001272             elseif l:isPrv || l:isHelp || l:isQf || l:wintype ==# "command"
                                            " Set straight line
                                            call setwinvar(n, '&statusline',  "%#StraightLine#%{" .  "repeat('━',\ winwidth(win_id2win(".l:winid.")))" .  "}")
                            
  168              0.001928             elseif (n == l:bottomRightWin) &&  ((winwidth(n) + winwidth(1) + 1 ) == &columns) &&  l:taglistWin == 1
                            
                                            " Only two windows in the bottom
                                            " Two arrows for mode label
   10              0.000156                 call setwinvar(n, '&statusline', "%!SetStatusLine(".l:winid.", 1)")
                            
  158              0.000300             else
                                            " Other windows status lines
  158              0.002563                 call setwinvar(n, '&statusline', "%!SetStatusLine(".l:winid.", 0)")
  201              0.000450             end
                            
  201              0.000337         endif
                            
  236              0.000614     endfor

FUNCTION  <SNR>6_SetUpCommands()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1175
Called 1 time
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
    1              0.000012   command! YcmRestartServer call s:RestartServer()
    1              0.000005   command! YcmDebugInfo call s:DebugInfo()
    1              0.000013   command! -nargs=* -complete=custom,youcompleteme#LogsComplete -count=0 YcmToggleLogs call s:ToggleLogs( <f-count>, <f-mods>, <f-args>)
    1              0.000089   if py3eval( 'vimsupport.VimVersionAtLeast( "7.4.1898" )' )
    1              0.000036     command! -nargs=* -complete=custom,youcompleteme#SubCommandsComplete -range YcmCompleter call s:CompleterCommand(<q-mods>,                                      <count>,                                      <line1>,                                      <line2>,                                      <f-args>)
                              else
                                command! -nargs=* -complete=custom,youcompleteme#SubCommandsComplete -range YcmCompleter call s:CompleterCommand('',                                      <count>,                                      <line1>,                                      <line2>,                                      <f-args>)
    1              0.000001   endif
    1              0.000005   command! YcmDiags call s:ShowDiagnostics()
    1              0.000006   command! YcmShowDetailedDiagnostic call s:ShowDetailedDiagnostic()
    1              0.000010   command! YcmForceCompileAndDiagnostics call s:ForceCompileAndDiagnostics()

FUNCTION  AsyncGitCallback()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:234
Called 3 times
Total time:   0.000781
 Self time:   0.000781

count  total (s)   self (s)
                            
    3              0.000013     if g:asyncrun_code != 0
                                    " If, for any reason, the command was not successfull, abort
                                    let s:GitStatus[a:buf]["LocalEnable"] = 0
                                    return
    3              0.000004     endif
                            
    3              0.000028     if !has_key(s:GitStatus, a:buf)
                                    let s:GitStatus[a:buf] = {"LocalEnable" : 1 ,"IsGit": 0, "RootDir": "", "BranchName": "",  "Dirty": "", "IsTracked": 0, "InsertNum": 0, "DeleteNum": 0, "CacheExpired": 0}
    3              0.000004     endif
                            
    3              0.000232     let l:lines = readfile(a:tmpfile)
    3              0.000017     let l:maxExpectedLines = 3
                            
    3              0.000009     if a:isFullUpdate
    1              0.000009         let s:GitStatus[a:buf]["RootDir"] = trim(fnamemodify(l:lines[0], ":h"))
    1              0.000006         let s:GitStatus[a:buf]["BranchName"] = trim(fnamemodify(l:lines[1], ":t"))
    1              0.000001         let l:maxExpectedLines = 5
    3              0.000005     endif
                            
    3              0.000062     let s:GitStatus[a:buf]["IsTracked"] = str2nr(l:lines[l:maxExpectedLines - 3])
    3              0.000019     let s:GitStatus[a:buf]["InsertNum"] = 0
    3              0.000027     let s:GitStatus[a:buf]["DeleteNum"] = 0
    3              0.000016     let s:GitStatus[a:buf]["Dirty"] = ""
                            
    3              0.000020     if len(l:lines) == l:maxExpectedLines
    1              0.000007         let s:GitStatus[a:buf]["Dirty"] = "*"
    1              0.000064         let l:splitdiff = split(l:lines[l:maxExpectedLines-1])
    1              0.000015         let s:GitStatus[a:buf]["InsertNum"] = trim(l:splitdiff[0])
    1              0.000011         let s:GitStatus[a:buf]["DeleteNum"] = trim(l:splitdiff[1])
                            
    2              0.000009     elseif len(l:lines) == l:maxExpectedLines-1
    2              0.000009         let s:GitStatus[a:buf]["Dirty"] = "*"
    3              0.000004     endif
                            
    3              0.000015     let s:GitStatus[a:buf]["IsGit"] = 1

FUNCTION  <SNR>6_SetUpBackwardsCompatibility()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:388
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000005   let complete_in_comments_and_strings = get( g:, 'ycm_complete_in_comments_and_strings', 0 )
                            
    1              0.000001   if complete_in_comments_and_strings
                                let g:ycm_complete_in_strings = 1
                                let g:ycm_complete_in_comments = 1
    1              0.000000   endif
                            
                              " ycm_filetypes_to_completely_ignore is the old name for fileype_blacklist
    1              0.000003   if has_key( g:, 'ycm_filetypes_to_completely_ignore' )
                                let g:filetype_blacklist =  g:ycm_filetypes_to_completely_ignore
    1              0.000000   endif

FUNCTION  <SNR>6_OnFileSave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:620
Called 2 times
Total time:   0.000096
 Self time:   0.000048

count  total (s)   self (s)
    2              0.000013   let buffer_number = str2nr( expand( '<abuf>' ) )
    2   0.000080   0.000032   if !s:AllowedToCompleteInBuffer( buffer_number )
    2              0.000002     return
                              endif
                              py3 ycm_state.OnFileSave( vimsupport.GetIntValue( 'buffer_number' ) )

FUNCTION  <SNR>6_TurnOffSyntasticForCFamily()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:405
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000004   let g:syntastic_cpp_checkers = []
    1              0.000004   let g:syntastic_c_checkers = []
    1              0.000001   let g:syntastic_objc_checkers = []
    1              0.000003   let g:syntastic_objcpp_checkers = []
    1              0.000002   let g:syntastic_cuda_checkers = []

FUNCTION  <SNR>6_SetUpOptions()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:114
Called 1 time
Total time:   0.000519
 Self time:   0.000057

count  total (s)   self (s)
    1   0.000202   0.000013   call s:SetUpCommands()
    1   0.000029   0.000007   call s:SetUpCpoptions()
    1   0.000028   0.000008   call s:SetUpCompleteopt()
    1   0.000150   0.000008   call s:SetUpKeyMappings()
                            
    1              0.000001   if g:ycm_show_diagnostics_ui
    1   0.000021   0.000007     call s:TurnOffSyntasticForCFamily()
    1              0.000000   endif
                            
    1   0.000069   0.000006   call s:SetUpSigns()
    1   0.000019   0.000007   call s:SetUpSyntaxHighlighting()

FUNCTION  <SNR>2_Tlist_Window_Init()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:1536
Called 1 time
Total time:   0.016839
 Self time:   0.000941

count  total (s)   self (s)
    1   0.000090   0.000038     call s:Tlist_Log_Msg('Tlist_Window_Init()')
                            
                                " The 'readonly' option should not be set for the taglist buffer.
                                " If Vim is started as "view/gview" or if the ":view" command is
                                " used, then the 'readonly' option is set for all the buffers.
                                " Unset it for the taglist buffer
    1              0.000024     setlocal noreadonly
                            
                                " Set the taglist buffer filetype to taglist
    1   0.015399   0.000013     setlocal filetype=taglist
                            
                                " Define taglist window element highlighting
    1              0.000017     syntax match TagListComment '^" .*'
    1              0.000005     syntax match TagListFileName '^[^" ].*$'
    1              0.000003     syntax match TagListTitle '^  \S.*$'
    1              0.000005     syntax match TagListTagScope  '\s\[.\{-\}\]$'
                            
                                " Define the highlighting only if colors are supported
    1              0.000009     if has('gui_running') || &t_Co > 2
                                    " Colors to highlight various taglist window elements
                                    " If user defined highlighting group exists, then use them.
                                    " Otherwise, use default highlight groups.
    1              0.000003         if hlexists('MyTagListTagName')
                                        highlight link TagListTagName MyTagListTagName
    1              0.000001         else
    1              0.000004             highlight default link TagListTagName Search
    1              0.000001         endif
                                    " Colors to highlight comments and titles
    1              0.000002         if hlexists('MyTagListComment')
                                        highlight link TagListComment MyTagListComment
    1              0.000001         else
    1              0.000002             highlight clear TagListComment
    1              0.000003             highlight default link TagListComment Comment
    1              0.000000         endif
    1              0.000003         if hlexists('MyTagListTitle')
                                        highlight link TagListTitle MyTagListTitle
    1              0.000001         else
    1              0.000001             highlight clear TagListTitle
    1              0.000002             highlight default link TagListTitle Title
    1              0.000000         endif
    1              0.000003         if hlexists('MyTagListFileName')
                                        highlight link TagListFileName MyTagListFileName
    1              0.000001         else
    1              0.000001             highlight clear TagListFileName
    1              0.000026             highlight default TagListFileName guibg=Grey ctermbg=darkgray guifg=white ctermfg=white
    1              0.000001         endif
    1              0.000002         if hlexists('MyTagListTagScope')
                                        highlight link TagListTagScope MyTagListTagScope
    1              0.000001         else
    1              0.000001             highlight clear TagListTagScope
    1              0.000002             highlight default link TagListTagScope Identifier
    1              0.000001         endif
                                else
                                    highlight default TagListTagName term=reverse cterm=reverse
    1              0.000001     endif
                            
                                " Folding related settings
    1              0.000008     setlocal foldenable
    1              0.000006     setlocal foldminlines=0
    1              0.000003     setlocal foldmethod=manual
    1              0.000003     setlocal foldlevel=9999
    1              0.000002     if g:Tlist_Enable_Fold_Column
    1              0.000002         setlocal foldcolumn=3
                                else
                                    setlocal foldcolumn=0
    1              0.000001     endif
    1              0.000003     setlocal foldtext=v:folddashes.getline(v:foldstart)
                            
    1              0.000003     if s:tlist_app_name != "winmanager"
                                    " Mark buffer as scratch
    1              0.000005         silent! setlocal buftype=nofile
    1              0.000002         if s:tlist_app_name == "none"
    1              0.000004             silent! setlocal bufhidden=delete
    1              0.000001         endif
    1              0.000054         silent! setlocal noswapfile
                                    " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
                                    " buffers. So if the taglist buffer is unlisted, multiple taglist
                                    " windows will be opened. This bug is fixed in Vim 6.1 and above
    1              0.000003         if v:version >= 601
    1   0.000468   0.000008             silent! setlocal nobuflisted
    1              0.000001         endif
    1              0.000001     endif
                            
    1              0.000008     silent! setlocal nowrap
                            
                                " If the 'number' option is set in the source window, it will affect the
                                " taglist window. So forcefully disable 'number' option for the taglist
                                " window
    1              0.000004     silent! setlocal nonumber
    1              0.000004     if exists('&relativenumber')
    1              0.000004         silent! setlocal norelativenumber
    1              0.000001     endif
                            
                                " Use fixed height when horizontally split window is used
    1              0.000002     if g:Tlist_Use_Horiz_Window
                                    if v:version >= 602
                                        set winfixheight
                                    endif
    1              0.000001     endif
    1              0.000003     if !g:Tlist_Use_Horiz_Window && v:version >= 700
    1              0.000004         set winfixwidth
    1              0.000001     endif
                            
                                " Setup balloon evaluation to display tag prototype
    1              0.000005     if v:version >= 700 && has('balloon_eval')
                                    setlocal balloonexpr=Tlist_Ballon_Expr()
                                    set ballooneval
    1              0.000001     endif
                            
                                " Setup the cpoptions properly for the maps to work
    1              0.000004     let old_cpoptions = &cpoptions
    1              0.000007     set cpoptions&vim
                            
                                " Create buffer local mappings for jumping to the tags and sorting the list
    1              0.000020     nnoremap <buffer> <silent> <CR> :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    1              0.000014     nnoremap <buffer> <silent> o :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    1              0.000013     nnoremap <buffer> <silent> p :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    1              0.000012     nnoremap <buffer> <silent> P :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    1              0.000003     if v:version >= 700
    1              0.000011     nnoremap <buffer> <silent> t :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    1              0.000018     nnoremap <buffer> <silent> <C-t> :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    1              0.000001     endif
    1              0.000017     nnoremap <buffer> <silent> <2-LeftMouse> :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    1              0.000014     nnoremap <buffer> <silent> s :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    1              0.000008     nnoremap <buffer> <silent> + :silent! foldopen<CR>
    1              0.000009     nnoremap <buffer> <silent> - :silent! foldclose<CR>
    1              0.000009     nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
    1              0.000009     nnoremap <buffer> <silent> = :silent! %foldclose<CR>
    1              0.000010     nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
    1              0.000009     nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
    1              0.000006     nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
    1              0.000007     nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
    1              0.000007     nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
    1              0.000007     nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
    1              0.000006     nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
    1              0.000009     nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    1              0.000009     nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    1              0.000011     nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
    1              0.000008     nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
    1              0.000009     nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    1              0.000004     nnoremap <buffer> <silent> q :close<CR>
                            
                                " Insert mode mappings
    1              0.000010     inoremap <buffer> <silent> <CR> <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
                                " Windows needs return
    1              0.000009     inoremap <buffer> <silent> <Return> <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    1              0.000009     inoremap <buffer> <silent> o <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    1              0.000008     inoremap <buffer> <silent> p <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    1              0.000008     inoremap <buffer> <silent> P <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    1              0.000002     if v:version >= 700
    1              0.000008     inoremap <buffer> <silent> t <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    1              0.000009     inoremap <buffer> <silent> <C-t> <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    1              0.000001     endif
    1              0.000010     inoremap <buffer> <silent> <2-LeftMouse> <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    1              0.000008     inoremap <buffer> <silent> s <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    1              0.000006     inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
    1              0.000007     inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
    1              0.000006     inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
    1              0.000006     inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
    1              0.000006     inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
    1              0.000007     inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
    1              0.000006     inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
    1              0.000008     inoremap <buffer> <silent> <Space>       <C-o>:call <SID>Tlist_Window_Show_Info()<CR>
    1              0.000008     inoremap <buffer> <silent> u <C-o>:call <SID>Tlist_Window_Update_File()<CR>
    1              0.000008     inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
    1              0.000008     inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
    1              0.000009     inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    1              0.000008     inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    1              0.000008     inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    1              0.000007     inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    1              0.000009     inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    1              0.000004     inoremap <buffer> <silent> q    <C-o>:close<CR>
                            
                                " Map single left mouse click if the user wants this functionality
    1              0.000001     if g:Tlist_Use_SingleClick == 1
                                    " Contributed by Bindu Wavell
                                    " attempt to perform single click mapping, it would be much
                                    " nicer if we could nnoremap <buffer> ... however vim does
                                    " not fire the <buffer> <leftmouse> when you use the mouse
                                    " to enter a buffer.
                                    let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' . 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' . '<bar> endif <CR>'
                                    if maparg('<leftmouse>', 'n') == ''
                                        " no mapping for leftmouse
                                        exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
                                    else
                                        " we have a mapping
                                        let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
                                        let mapcmd = mapcmd . substitute(substitute( maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'), '\c^<leftmouse>', '', '')
                                        let mapcmd = mapcmd . clickmap
                                        exe mapcmd
                                    endif
    1              0.000000     endif
                            
                                " Define the taglist autocommands
    1              0.000003     augroup TagListAutoCmds
    1              0.000004         autocmd!
                                    " Display the tag prototype for the tag under the cursor.
    1              0.000008         autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
                                    " Highlight the current tag periodically
    1              0.000005         autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag( fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)
                            
                                    " Adjust the Vim window width when taglist window is closed
    1              0.000005         autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
                                    " Close the fold for this buffer when leaving the buffer
    1              0.000002         if g:Tlist_File_Fold_Auto_Close
                                        autocmd BufEnter * silent call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
    1              0.000000         endif
                                    " Exit Vim itself if only the taglist window is present (optional)
    1              0.000001         if g:Tlist_Exit_OnlyWindow
                            	    autocmd BufEnter __Tag_List__ nested call s:Tlist_Window_Exit_Only_Window()
    1              0.000000         endif
    1              0.000009         if s:tlist_app_name != "winmanager" && !g:Tlist_Process_File_Always && (!has('gui_running') || !g:Tlist_Show_Menu)
                                        " Auto refresh the taglist window
    1              0.000004             autocmd BufEnter * call s:Tlist_Refresh()
    1              0.000001         endif
                            
    1              0.000001         if !g:Tlist_Use_Horiz_Window
    1              0.000002             if v:version < 700
                                            autocmd WinEnter * call s:Tlist_Window_Check_Width()
    1              0.000000             endif
    1              0.000000         endif
    1              0.000001         if v:version >= 700
    1              0.000007             autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
    1              0.000001         endif
    1              0.000001     augroup end
                            
                                " Restore the previous cpoptions settings
    1              0.000006     let &cpoptions = old_cpoptions

FUNCTION  <SNR>2_Tlist_Log_Msg()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:743
Called 12 times
Total time:   0.000706
 Self time:   0.000706

count  total (s)   self (s)
   12              0.000065     if s:tlist_debug
                                    if s:tlist_debug_file != ''
                                        exe 'redir >> ' . s:tlist_debug_file
                                        silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
                                        redir END
                                    else
                                        " Log the message into a variable
                                        " Retain only the last 3000 characters
                                        let len = strlen(s:tlist_msg)
                                        if len > 3000
                                            let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
                                        endif
                                        let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' .  a:msg . "\n"
                                    endif
   12              0.000025     endif

FUNCTION  Tlist_Get_Tag_Prototype_By_Line()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:3942
Called 3 times
Total time:   0.000300
 Self time:   0.000276

count  total (s)   self (s)
    3              0.000009     if a:0 == 0
                                    " Arguments are not supplied. Use the current buffer name
                                    " and line number
    3              0.000019         let filename = bufname('%')
    3              0.000012         let linenr = line('.')
                                elseif a:0 == 2
                                    " Filename and line number are specified
                                    let filename = a:1
                                    let linenr = a:2
                                    if linenr !~ '\d\+'
                                        " Invalid line number
                                        return ""
                                    endif
                                else
                                    " Sufficient arguments are not supplied
                                    let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' . '<line_number>'
                                    call s:Tlist_Warning_Msg(msg)
                                    return ""
    3              0.000003     endif
                            
                                " Expand the file to a fully qualified name
    3              0.000080     let filename = fnamemodify(filename, ':p')
    3              0.000009     if filename == ''
                                    return ""
    3              0.000004     endif
                            
    3   0.000069   0.000045     let fidx = s:Tlist_Get_File_Index(filename)
    3              0.000006     if fidx == -1
    3              0.000004         return ""
                                endif
                            
                                " If there are no tags for this file, then no need to proceed further
                                if s:tlist_{fidx}_tag_count == 0
                                    return ""
                                endif
                            
                                " Get the tag text using the line number
                                let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
                                if tidx == -1
                                    return ""
                                endif
                            
                                return s:Tlist_Get_Tag_Prototype(fidx, tidx)

FUNCTION  <SNR>3_run()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:1363
Called 3 times
Total time:   0.008799
 Self time:   0.001103

count  total (s)   self (s)
    3              0.000050 	let l:opts = deepcopy(a:opts)
    3              0.000005 	let l:command = a:opts.cmd
    3              0.000004 	let l:retval = ''
    3              0.000004 	let l:mode = g:asyncrun_mode
    3              0.000003 	let l:runner = ''
    3              0.000004 	let l:opts.origin = l:opts.cmd
                            
    3              0.000003 	if a:opts.mode != ''
                            		let l:mode = a:opts.mode
    3              0.000000 	endif
                            
                            	" mode alias
    3              0.000018 	let l:modemap = {'async':0, 'make':1, 'bang':2, 'python':3, 'os':4, 'hide':5, 'terminal': 6, 'execute':1, 'term':6, 'system':4}
                            
    3              0.000007 	let l:modemap['external'] = 4
    3              0.000004 	let l:modemap['quickfix'] = 0
    3              0.000005 	let l:modemap['vim'] = 2
                            
    3              0.000008 	let l:mode = get(l:modemap, l:mode, l:mode)
                            
                            	" alias "-mode=raw" to "-mode=async -raw=1"
    3              0.000009 	if type(l:mode) == type('') && l:mode == 'raw'
                            		let l:mode = 0
                            		let l:opts.raw = 1
    3              0.000006 	elseif type(l:mode) == 0 && l:mode == 6
                            		let pos = get(l:opts, 'pos', '')
                            		if has_key(g:asyncrun_runner, pos)
                            			let l:runner = pos
                            		elseif pos == 'bang' || pos == 'vim'
                            			let l:mode = 2
                            		elseif pos == 'extern' || pos == 'external'
                            			let l:mode = 4
                            		elseif pos == 'system' || pos == 'os'
                            			let l:mode = 4
                            		elseif pos == 'quickfix'
                            			let l:mode = 0
                            			let l:opts.raw = 1
                            		endif
    3              0.000001 	endif
                            
                            	" process makeprg/grepprg in -program=?
    3              0.000003 	let l:program = ""
                            
    3              0.000006 	let s:async_efm = a:opts.errorformat
                            
    3              0.000003 	if l:opts.program == 'make'
                            		let l:program = &makeprg
    3              0.000004 	elseif l:opts.program == 'grep'
                            		let l:program = &grepprg
                            		let s:async_efm = &grepformat
    3              0.000003 	elseif l:opts.program == 'wsl'
                            		if s:asyncrun_windows != 0
                            			let root = ($SystemRoot == '')? 'C:/Windows' : $SystemRoot
                            			let t1 = root . '/system32/wsl.exe'
                            			let t2 = root . '/sysnative/wsl.exe'
                            			let tt = executable(t1)? t1 : (executable(t2)? t2 : '')
                            			if tt == ''
                            				call s:ErrorMsg("not find wsl in your system")
                            				return
                            			endif
                            			let cmd = s:shellescape(substitute(tt, '\\', '\/', 'g'))
                            			let dist = get(l:opts, 'dist', get(g:, 'asyncrun_dist', ''))
                            			if dist != ''
                            				let cmd = cmd . ' -d ' . dist
                            			endif
                            			let l:command = cmd . ' ' . l:command
                            		else
                            			call s:ErrorMsg("only available for Windows")
                            			return ''
                            		endif
    3              0.000003 	elseif l:opts.program != ''
                            		let name = l:opts.program
                            		let test = ['cygwin', 'msys', 'mingw32', 'mingw64']
                            		if index(test, name) >= 0
                            			unsilent let l:command = s:program_msys(l:opts)
                            		else
                            			if has_key(g:asyncrun_program, name) == 0
                            				call s:ErrorMsg(name . " not found in g:asyncrun_program")
                            				return ''
                            			endif
                            			let F = g:asyncrun_program[name]
                            			if type(F) == type('')
                            				let F = function(F)
                            			endif
                            			unsilent let l:command = F(l:opts)
                            		endif
                            		if l:command == ''
                            			return ''
                            		endif
                            		let l:opts.cmd = l:command
    3              0.000002 	endif
                            
    3              0.000003 	if l:program != ''
                            		if l:program =~# '\$\*'
                            			let l:command = s:StringReplace(l:program, '\$\*', l:command)
                            		elseif l:command != ''
                            			let l:command = l:program . ' ' . l:command
                            		else
                            			let l:command = l:program
                            		endif
                            		let l:command = s:StringStrip(l:command)
                            		let s:async_program_cmd = ''
                            		silent exec 'AsyncRun -program=parse @ '. l:command
                            		let l:command = s:async_program_cmd
    3              0.000000 	endif
                            
    3              0.000015 	if l:command =~ '^\s*$'
                            		echohl ErrorMsg
                            		echom "E471: Command required"
                            		echohl NONE
                            		return
    3              0.000002 	endif
                            
    3              0.000009 	let l:wrapper = get(g:, 'asyncrun_wrapper', '')
                            
    3              0.000003 	if l:wrapper != ''
                            		let l:command = l:wrapper . ' ' . l:command
    3              0.000001 	endif
                            
    3              0.000004 	if l:mode >= 10
                            		let l:opts.cmd = l:command
                            		if g:asyncrun_hook != ''
                            			exec 'call '. g:asyncrun_hook .'(l:opts)'
                            		endif
                            		return ''
    3              0.000003 	elseif l:mode == 7
                            		if s:asyncrun_windows != 0 && s:asyncrun_gui != 0
                            			let l:mode = 4
                            		else
                            			let script = get(g:, 'asyncrun_script', '')
                            			let l:mode = (script == '')? 2 : 4
                            		endif
    3              0.000002 	endif
                            
    3              0.000006 	let g:asyncrun_cmd = l:command
    3   0.000293   0.000016 	let t = s:StringStrip(l:command)
                            
    3              0.000010 	if strpart(t, 0, 1) == ':' && g:asyncrun_strict == 0
                            		exec strpart(t, 1)
                            		return ''
    3              0.000009 	elseif l:runner != ''
                            		let F = g:asyncrun_runner[l:runner]
                            		if type(F) == type('')
                            			let F = function(F)
                            		endif
                            		let obj = deepcopy(l:opts)
                            		let obj.cmd = command
                            		let obj.src = a:opts.cmd
                            		call F(obj)
                            		return ''
    3              0.000001 	endif
                            
    3              0.000006 	if exists('g:asyncrun_open')
                            		let s:asyncrun_open = g:asyncrun_open
                            		if has_key(a:opts, 'open')
                            			let s:asyncrun_open = a:opts.open
                            		endif
                            		if has_key(a:opts, 'silent')
                            			if a:opts.silent
                            				let s:asyncrun_open = 0
                            			endif
                            		endif
    3              0.000001 	endif
                            
    3              0.000006 	if l:mode == 0 && s:asyncrun_support != 0
    3              0.000008 		let s:async_info.postsave = opts.post
    3              0.000003 		let s:async_info.autosave = opts.auto
    3              0.000005 		let s:async_info.text = opts.text
    3              0.000004 		let s:async_info.raw = opts.raw
    3              0.000004 		let s:async_info.range = opts.range
    3              0.000006 		let s:async_info.range_top = opts.range_top
    3              0.000003 		let s:async_info.range_bot = opts.range_bot
    3              0.000003 		let s:async_info.range_buf = opts.range_buf
    3              0.000005 		let s:async_info.strip = opts.strip
    3              0.000004 		let s:async_info.append = opts.append
    3   0.007464   0.000045 		if s:AsyncRun_Job_Start(l:command) != 0
                            			call s:AutoCmd('Error')
    3              0.000005 		endif
                            	elseif l:mode <= 1 && has('quickfix')
                            		call s:AutoCmd('Pre')
                            		call s:AutoCmd('Start')
                            		let l:makesave = &l:makeprg
                            		let l:script = s:ScriptWrite(l:command, 0)
                            		if s:asyncrun_windows != 0
                            			let &l:makeprg = s:shellescape(l:script)
                            		else
                            			let &l:makeprg = 'source '. s:shellescape(l:script)
                            		endif
                            		let l:efm1 = &g:efm
                            		let l:efm2 = &l:efm
                            		if g:asyncrun_local != 0
                            			let &g:efm = s:async_efm
                            			let &l:efm = s:async_efm
                            		endif
                            		if has('autocmd')
                            			call s:AsyncRun_Job_AutoCmd(0, opts.auto)
                            			exec "noautocmd make!"
                            			call s:AsyncRun_Job_AutoCmd(1, opts.auto)
                            		else
                            			exec "make!"
                            		endif
                            		if g:asyncrun_local != 0
                            			if l:efm1 != &g:efm | let &g:efm = l:efm1 | endif
                            			if l:efm2 != &l:efm | let &l:efm = l:efm2 | endif
                            		endif
                            		let &l:makeprg = l:makesave
                            		if s:asyncrun_windows == 0
                            			try | call delete(l:script) | catch | endtry
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            		call s:AutoCmd('Stop')
                            	elseif l:mode <= 2
                            		let autocmd = get(opts, 'autocmd', 0)
                            		if autocmd != 0
                            			call s:AutoCmd('Pre')
                            			call s:AutoCmd('Start')
                            		endif
                            		exec '!'. escape(l:command, '%#')
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            		if autocmd != 0
                            			call s:AutoCmd('Stop')
                            		endif
                            	elseif l:mode == 3
                            		if s:asyncrun_windows == 0
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		elseif has('nvim')
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		elseif has('python3')
                            			let l:script = s:ScriptWrite(l:command, 0)
                            			py3 import subprocess, vim
                            			py3 argv = {'args': vim.eval('l:script'), 'shell': True}
                            			py3 argv['stdout'] = subprocess.PIPE
                            			py3 argv['stderr'] = subprocess.STDOUT
                            			py3 p = subprocess.Popen(**argv)
                            			py3 text = p.stdout.read()
                            			py3 p.stdout.close()
                            			py3 c = p.wait()
                            			if has('patch-7.4.145')
                            				let l:retval = py3eval('text')
                            				let g:asyncrun_shell_error = py3eval('c')
                            			else
                            				py3 text = text.replace('\\', '\\\\').replace('"', '\\"')
                            				py3 text = text.replace('\n', '\\n').replace('\r', '\\r')
                            				py3 vim.command('let l:retval = "%s"'%text)
                            				py3 vim.command('let g:asyncrun_shell_error = %d'%c)
                            			endif
                            		elseif has('python')
                            			let l:script = s:ScriptWrite(l:command, 0)
                            			py import subprocess, vim
                            			py argv = {'args': vim.eval('l:script'), 'shell': True}
                            			py argv['stdout'] = subprocess.PIPE
                            			py argv['stderr'] = subprocess.STDOUT
                            			py p = subprocess.Popen(**argv)
                            			py text = p.stdout.read()
                            			py p.stdout.close()
                            			py c = p.wait()
                            			if has('patch-7.4.145')
                            				let l:retval = pyeval('text')
                            				let g:asyncrun_shell_error = pyeval('c')
                            			else
                            				py text = text.replace('\\', '\\\\').replace('"', '\\"')
                            				py text = text.replace('\n', '\\n').replace('\r', '\\r')
                            				py vim.command('let l:retval = "%s"'%text)
                            				py vim.command('let g:asyncrun_shell_error = %d'%c)
                            			endif
                            		else
                            			let l:retval = system(l:command)
                            			let g:asyncrun_shell_error = v:shell_error
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            	elseif l:mode <= 5
                            		let script = get(g:, 'asyncrun_script', '')
                            		if script != '' && l:mode == 4
                            			let $VIM_COMMAND = l:command
                            			let l:command = script . ' ' . l:command
                            			if s:asyncrun_windows
                            				let ccc = s:shellescape(s:ScriptWrite(l:command, 0))
                            				silent exec '!start /b cmd /C '. ccc
                            			else
                            				call system(l:command . ' &')
                            			endif
                            		elseif s:asyncrun_windows
                            			if l:mode == 4
                            				let l:ccc = s:shellescape(s:ScriptWrite(l:command, 1))
                            				silent exec '!start cmd /C '. l:ccc
                            			else
                            				let l:ccc = s:shellescape(s:ScriptWrite(l:command, 0))
                            				silent exec '!start /b cmd /C '. l:ccc
                            			endif
                            			redraw
                            		else
                            			if l:mode == 4
                            				exec '!' . escape(l:command, '%#')
                            			else
                            				call system(l:command . ' &')
                            			endif
                            		endif
                            		let g:asyncrun_text = opts.text
                            		if opts.post != ''
                            			exec opts.post
                            		endif
                            	elseif l:mode == 6
                            		let opts.cmd = l:command
                            		call s:start_in_terminal(opts)
    3              0.000002 	endif
                            
    3              0.000005 	return l:retval

FUNCTION  <SNR>6_ClearSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1159
Called 2 times
Total time:   0.002661
 Self time:   0.000468

count  total (s)   self (s)
    2   0.002212   0.000060   if !s:ShouldUseSignatureHelp()
                                return
    2              0.000005   endif
                            
    2   0.000101   0.000060   call s:StopPoller( s:pollers.signature_help )
    2              0.000017   let s:signature_help = s:default_signature_help
    2              0.000297   call py3eval( 'ycm_state.ClearSignatureHelp()' )

FUNCTION  <SNR>3_AsyncRun_Job_Start()
    Defined: ~/.vim/bundle/asyncrun.vim/plugin/asyncrun.vim:628
Called 3 times
Total time:   0.007419
 Self time:   0.006925

count  total (s)   self (s)
    3              0.000003 	let l:running = 0
    3              0.000004 	let l:empty = 0
    3              0.000004 	if s:asyncrun_support == 0
                            		call s:NotSupport()
                            		return -1
    3              0.000001 	endif
    3              0.000006 	if exists('s:async_job')
                            		if !has('nvim')
                            			if job_status(s:async_job) == 'run'
                            				let l:running = 1
                            			endif
                            		else
                            			if s:async_job > 0
                            				let l:running = 1
                            			endif
                            		endif
    3              0.000001 	endif
    3              0.000006 	if type(a:cmd) == 1
    3              0.000008 		if a:cmd == '' | let l:empty = 1 | endif
                            	elseif type(a:cmd) == 3
                            		if a:cmd == [] | let l:empty = 1 | endif
    3              0.000001 	endif
    3              0.000006 	if s:async_state != 0 || l:running != 0
                            		call s:ErrorMsg("background job is still running")
                            		return -2
    3              0.000000 	endif
    3              0.000003 	if l:empty != 0
                            		call s:ErrorMsg("empty arguments")
                            		return -3
    3              0.000002 	endif
    3              0.000005 	let l:args = []
    3              0.000004 	if g:asyncrun_shell == ''
    3              0.000024 		let l:args += split(&shell)
    3              0.000011 		let l:args += split(&shellcmdflag)
                            	else
                            		let l:args += split(g:asyncrun_shell)
                            		let l:args += split(g:asyncrun_shellflag)
    3              0.000002 	endif
    3              0.000006 	let s:async_info.errorformat = s:async_efm
    3              0.000003 	let l:name = []
    3              0.000004 	if type(a:cmd) == 1
    3              0.000005 		let l:name = a:cmd
    3              0.000003 		if s:asyncrun_windows == 0
    3              0.000006 			let l:args += [a:cmd]
                            		else
                            			let l:tmp = s:ScriptWrite(a:cmd, 0)
                            			if s:async_nvim == 0
                            				let l:args += [l:tmp]
                            			else
                            				let l:args = s:shellescape(l:tmp)
                            			endif
    3              0.000001 		endif
                            	elseif type(a:cmd) == 3
                            		if s:asyncrun_windows == 0
                            			let l:temp = []
                            			for l:item in a:cmd
                            				if index(['|', '`'], l:item) < 0
                            					let l:temp += [fnameescape(l:item)]
                            				else
                            					let l:temp += ['|']
                            				endif
                            			endfor
                            			let l:args += [join(l:temp, ' ')]
                            		else
                            			let l:args += a:cmd
                            		endif
                            		let l:vector = []
                            		for l:x in a:cmd
                            			let l:vector += ['"'.l:x.'"']
                            		endfor
                            		let l:name = join(l:vector, ', ')
    3              0.000001 	endif
    3              0.000006 	let s:async_state = 0
    3              0.000005 	let s:async_output = {}
    3              0.000003 	let s:async_head = 0
    3              0.000003 	let s:async_tail = 0
    3              0.000006 	let s:async_info.post = s:async_info.postsave
    3              0.000004 	let s:async_info.auto = s:async_info.autosave
    3              0.000004 	let s:async_info.postsave = ''
    3              0.000003 	let s:async_info.autosave = ''
    3              0.000007 	let g:asyncrun_text = s:async_info.text
    3   0.000126   0.000021 	call s:AutoCmd('Pre')
    3              0.000003 	if s:async_nvim == 0
    3              0.000005 		let l:options = {}
    3              0.000033 		let l:options['callback'] = function('s:AsyncRun_Job_OnCallback')
    3              0.000011 		let l:options['close_cb'] = function('s:AsyncRun_Job_OnClose')
    3              0.000028 		let l:options['exit_cb'] = function('s:AsyncRun_Job_OnExit')
    3              0.000006 		let l:options['out_io'] = 'pipe'
    3              0.000003 		let l:options['err_io'] = 'out'
    3              0.000005 		let l:options['in_io'] = 'null'
    3              0.000005 		let l:options['out_mode'] = 'nl'
    3              0.000004 		let l:options['err_mode'] = 'nl'
    3              0.000005 		let l:options['stoponexit'] = 'term'
    3              0.000016 		if g:asyncrun_stop != ''
                            			let l:options['stoponexit'] = g:asyncrun_stop
    3              0.000002 		endif
    3              0.000003 		if s:async_info.range > 0
                            			let l:options['in_io'] = 'buffer'
                            			let l:options['in_mode'] = 'nl'
                            			let l:options['in_buf'] = s:async_info.range_buf
                            			let l:options['in_top'] = s:async_info.range_top
                            			let l:options['in_bot'] = s:async_info.range_bot
    3              0.000009 		elseif exists('*ch_close_in')
    3              0.000003 			if g:asyncrun_stdin != 0
                            				let l:options['in_io'] = 'pipe'
    3              0.000002 			endif
    3              0.000002 		endif
    3              0.001913 		let s:async_job = job_start(l:args, l:options)
    3              0.000028 		let l:success = (job_status(s:async_job) != 'fail')? 1 : 0
    3              0.000008 		if l:success && l:options['in_io'] == 'pipe'
                            			silent! call ch_close_in(job_getchannel(s:async_job))
    3              0.000002 		endif
                            	else
                            		let l:callbacks = {'shell': 'AsyncRun'}
                            		let l:callbacks['on_stdout'] = function('s:AsyncRun_Job_NeoVim')
                            		let l:callbacks['on_stderr'] = function('s:AsyncRun_Job_NeoVim')
                            		let l:callbacks['on_exit'] = function('s:AsyncRun_Job_NeoVim')
                            		let s:neovim_stdout = ''
                            		let s:neovim_stderr = ''
                            		let s:async_job = jobstart(l:args, l:callbacks)
                            		let l:success = (s:async_job > 0)? 1 : 0
                            		if l:success != 0
                            			if s:async_info.range > 0
                            				let l:top = s:async_info.range_top
                            				let l:bot = s:async_info.range_bot
                            				let l:lines = getline(l:top, l:bot)
                            				if exists('*chansend')
                            					call chansend(s:async_job, l:lines)
                            				elseif exists('*jobsend')
                            					call jobsend(s:async_job, l:lines)
                            				endif
                            			endif
                            			if exists('*chanclose')
                            				call chanclose(s:async_job, 'stdin')
                            			elseif exists('*jobclose')
                            				call jobclose(s:async_job, 'stdin')
                            			endif
                            		endif
    3              0.000015 	endif
    3              0.000004 	if l:success != 0
    3              0.000019 		let s:async_state = or(s:async_state, 1)
    3              0.000010 		let g:asyncrun_status = "running"
    3              0.000006 		let s:async_start = localtime()
    3              0.000014 		let l:arguments = "[".l:name."]"
    3              0.000010 		let l:title = ':AsyncRun '.l:name
    3              0.000006 		if !s:async_info.append
    3              0.000003 			if s:async_nvim == 0
    3              0.000006 				if v:version >= 800 || has('patch-7.4.2210')
    3              0.000055 					call setqflist([], ' ', {'title':l:title})
                            				else
                            					call setqflist([], ' ')
    3              0.000001 				endif
                            			else
                            				call setqflist([], ' ', l:title)
    3              0.000002 			endif
    3              0.000002 		endif
    3              0.000004 		if !s:async_info.strip
    3              0.000019 			call setqflist([{'text':l:arguments}], 'a')
    3              0.000003 		endif
    3              0.000013 		let l:name = 'g:AsyncRun_Job_OnTimer'
    3              0.000025 		let s:async_timer = timer_start(100, l:name, {'repeat':-1})
    3   0.000184   0.000103 		call s:AsyncRun_Job_AutoCmd(0, s:async_info.auto)
    3   0.000335   0.000027 		call s:AutoCmd('Start')
    3              0.003928 		redrawstatus!
                            	else
                            		unlet s:async_job
                            		call s:ErrorMsg("Background job start failed '".a:cmd."'")
                            		redrawstatus!
                            		return -5
    3              0.000002 	endif
    3              0.000009 	return 0

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  485   0.312954   0.071445  SetStatusLine()
    2   0.114561   0.114402  <SNR>6_PollServerReady()
  485   0.099349   0.047540  <SNR>5_BuildFilenameLbl()
    1   0.090451   0.000190  youcompleteme#Enable()
    1   0.089684             <SNR>6_SetUpPython()
  485   0.079237   0.075455  <SNR>5_GitInit()
  485   0.062923             <SNR>5_BuildInfBar()
    2   0.046114   0.000530  <SNR>2_Tlist_Window_Open()
  485   0.045179             <SNR>5_GetFilename()
    1   0.044783   0.000226  <SNR>2_Tlist_Window_Toggle()
    1   0.043587   0.024301  <SNR>2_Tlist_Window_Create()
   35   0.040995             <SNR>5_ManageWinStl()
   82   0.037194             <SNR>6_PollFileParseResponse()
  167   0.025896   0.006670  <SNR>6_OnCursorMovedNormalMode()
    3   0.022925   0.000890  <SNR>5_GitUpdate()
    3   0.022035   0.004477  asyncrun#run()
  183   0.021809   0.005700  <SNR>6_AllowedToCompleteInCurrentBuffer()
    6   0.020230   0.018981  <SNR>6_ReceiveMessages()
    3   0.019152   0.000592  AsyncRun_Job_OnTimer()
    3   0.017263   0.014827  <SNR>3_AsyncRun_Job_OnFinish()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.114561   0.114402  <SNR>6_PollServerReady()
    1              0.089684  <SNR>6_SetUpPython()
  485   0.079237   0.075455  <SNR>5_GitInit()
  485   0.312954   0.071445  SetStatusLine()
  485              0.062923  <SNR>5_BuildInfBar()
  485   0.099349   0.047540  <SNR>5_BuildFilenameLbl()
  485              0.045179  <SNR>5_GetFilename()
   35              0.040995  <SNR>5_ManageWinStl()
   82              0.037194  <SNR>6_PollFileParseResponse()
    1   0.043587   0.024301  <SNR>2_Tlist_Window_Create()
    6   0.020230   0.018981  <SNR>6_ReceiveMessages()
  187   0.016593   0.015814  <SNR>6_AllowedToCompleteInBuffer()
    3   0.017263   0.014827  <SNR>3_AsyncRun_Job_OnFinish()
    2   0.012444   0.009717  <SNR>6_OnFileReadyToParse()
   37              0.007933  <SNR>6_UpdateMatches()
    2   0.007898   0.007462  <SNR>6_OnBufferUnload()
    3   0.007419   0.006925  <SNR>3_AsyncRun_Job_Start()
    2   0.015494   0.006868  <SNR>6_OnFileTypeSet()
  167   0.025896   0.006670  <SNR>6_OnCursorMovedNormalMode()
  183   0.021809   0.005700  <SNR>6_AllowedToCompleteInCurrentBuffer()

