FUNCTION  indent_guides#indent_highlight_pattern()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:269
Called 58 times
Total time:   0.000511
 Self time:   0.000511

count  total (s)   self (s)
   58              0.000167   let l:pattern  = '^' . a:indent_pattern . '*\%' . a:column_start . 'v\zs'
   58              0.000182   let l:pattern .= a:indent_pattern . '*\%' . (a:column_start + a:indent_size) . 'v'
   58              0.000074   let l:pattern .= '\ze'
   58              0.000050   return l:pattern

FUNCTION  <SNR>3_SynSet()
    Defined: /usr/local/share/vim/vim82/syntax/synload.vim:33
Called 1 time
Total time:   0.026431
 Self time:   0.000358

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000004   syn clear
    1              0.000003   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000005   let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000009     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1   0.026384   0.000311 	exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000001       endif
    2              0.000002     endfor
    1              0.000000   endif

FUNCTION  <SNR>39_ReceiveMessages()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:97
Called 2 times
Total time:   0.005905
 Self time:   0.005273

count  total (s)   self (s)
    2              0.000051   let poll_again = v:false
    2   0.000693   0.000061   if s:AllowedToCompleteInCurrentBuffer()
    2              0.005011     let poll_again = py3eval( 'ycm_state.OnPeriodicTick()' )
    2              0.000016   endif
                            
    2              0.000012   if poll_again
    1              0.000056     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    1              0.000002   else
                                " Don't poll again until we open another buffer
    1              0.000009     let s:pollers.receive_messages.id = -1
    2              0.000004   endif

FUNCTION  <SNR>35_foldable()
    Defined: /usr/local/share/vim/vim82/syntax/ruby.vim:40
Called 159 times
Total time:   0.001109
 Self time:   0.001109

count  total (s)   self (s)
  159              0.000352   if index(s:foldable_groups, 'NONE') > -1
                                return 0
  159              0.000096   endif
                            
  159              0.000251   if index(s:foldable_groups, 'ALL') > -1
  159              0.000114     return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  <SNR>39_SetUpKeyMappings()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:265
Called 1 time
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
                              " The g:ycm_key_select_completion and g:ycm_key_previous_completion used to
                              " exist and are now here purely for the sake of backwards compatibility; we
                              " don't want to break users if we can avoid it.
                            
    1              0.000005   if exists('g:ycm_key_select_completion') && index(g:ycm_key_list_select_completion,       g:ycm_key_select_completion) == -1
                                call add(g:ycm_key_list_select_completion, g:ycm_key_select_completion)
    1              0.000000   endif
                            
    1              0.000003   if exists('g:ycm_key_previous_completion') && index(g:ycm_key_list_previous_completion,       g:ycm_key_previous_completion) == -1
                                call add(g:ycm_key_list_previous_completion, g:ycm_key_previous_completion)
    1              0.000000   endif
                            
    3              0.000008   for key in g:ycm_key_list_select_completion
                                " With this command, when the completion window is visible, the tab key
                                " (default) will select the next candidate in the window. In vim, this also
                                " changes the typed-in text to that of the candidate completion.
    2              0.000037     exe 'inoremap <expr>' . key .  ' pumvisible() ? "\<C-n>" : "\' . key .'"'
    3              0.000002   endfor
                            
    3              0.000004   for key in g:ycm_key_list_previous_completion
                                " This selects the previous candidate for shift-tab (default)
    2              0.000059     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
    3              0.000002   endfor
                            
    2              0.000002   for key in g:ycm_key_list_stop_completion
                                " When selecting a candidate and closing the completion menu with the <C-y>
                                " key, the menu will automatically be reopened because of the TextChangedI
                                " event. We define a command to prevent that.
    1              0.000012     exe 'inoremap <expr>' . key . ' <SID>StopCompletion( "\' . key . '" )'
    2              0.000001   endfor
                            
    1              0.000002   if !empty( g:ycm_key_invoke_completion )
    1              0.000003     let invoke_key = g:ycm_key_invoke_completion
                            
                                " Inside the console, <C-Space> is passed as <Nul> to Vim
    1              0.000002     if invoke_key ==# '<C-Space>'
    1              0.000005       imap <Nul> <C-Space>
    1              0.000001     endif
                            
    1              0.000012     silent! exe 'inoremap <unique> <silent> ' . invoke_key . ' <C-R>=<SID>RequestSemanticCompletion()<CR>'
    1              0.000001   endif
                            
    1              0.000002   if !empty( g:ycm_key_detailed_diagnostics )
    1              0.000014     silent! exe 'nnoremap <unique> ' . g:ycm_key_detailed_diagnostics . ' :YcmShowDetailedDiagnostic<CR>'
    1              0.000001   endif
                            
    1              0.000002   if s:completion_api == s:COMPLETION_COMPLETEFUNC
                                " The TextChangedI event is not triggered when deleting a character while
                                " the completion menu is open. We handle this by closing the completion menu
                                " on the keys that delete a character in insert mode.
                                for key in [ "<BS>", "<C-h>" ]
                                  silent! exe 'inoremap <unique> <expr> ' . key . ' <SID>OnDeleteChar( "\' . key . '" )'
                                endfor
    1              0.000000   endif

FUNCTION  1()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:267
Called 8 times
Total time:   0.000139
 Self time:   0.000056

count  total (s)   self (s)
    8   0.000138   0.000055   return s:expand_path(g:vundle#bundle_dir.'/') . self.name

FUNCTION  <SNR>39_ClearSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1159
Called 1 time
Total time:   0.003560
 Self time:   0.000466

count  total (s)   self (s)
    1   0.003079   0.000031   if !s:ShouldUseSignatureHelp()
                                return
    1              0.000007   endif
                            
    1   0.000095   0.000049   call s:StopPoller( s:pollers.signature_help )
    1              0.000019   let s:signature_help = s:default_signature_help
    1              0.000339   call py3eval( 'ycm_state.ClearSignatureHelp()' )

FUNCTION  SetStatusLine()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:325
Called 2 times
Total time:   0.000293
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000010     if !has_key(s:gitSts, bufname())
    1              0.000007         let s:gitSts[bufname()] = {"GitAvail"      : "-1", "RootDir"     : "", "BranchName"  : "", "InsertNum"   : -1, "DeleteNum"   : -1, "CacheTimeout" : 50}
                            
    2              0.000002     endif
                            
                                " Start of main window status line
                                " Mode
    2   0.000063   0.000012     let l:sts   = s:BuildModeLbl()
                            
                                " File of function name
    2   0.000100   0.000012     let l:sts  .= s:BuildFilenameLbl()
                             
                                " Left align
    2              0.000002     let l:sts .= "%="
                                
                                " File flags
    2   0.000045   0.000010     let l:sts .= s:BuildFlags()
                              
                                " Information bar
    2   0.000049   0.000010     let l:sts .= s:BuildInfBar()
                            
    2              0.000002     return l:sts

FUNCTION  <SNR>39_PollFileParseResponse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:702
Called 1 time
Total time:   0.009414
 Self time:   0.009414

count  total (s)   self (s)
    1              0.000194   if !py3eval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
    1              0.000003   endif
                            
    1              0.009026   py3 ycm_state.HandleFileParseRequest()
    1              0.000134   if py3eval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
    1              0.000003   endif

FUNCTION  <SNR>9_rtp_add_a()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:198
Called 1 time
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    1              0.000009   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')
    1              0.000004   let prepends = join(paths, ',')
    1              0.000004   let appends = join(paths, '/after,').'/after'
    1              0.000059   exec 'set rtp^='.fnameescape(prepends)
    1              0.000065   exec 'set rtp+='.fnameescape(appends)

FUNCTION  vundle#config#init_bundle()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:75
Called 8 times
Total time:   0.001090
 Self time:   0.000380

count  total (s)   self (s)
    8              0.000104   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
                                echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
    8              0.000008   endif
    8   0.000664   0.000153   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
    8              0.000039   let b = extend(opts, copy(s:bundle))
    8   0.000245   0.000046   let b.rtpath = s:rtpath(opts)
    8              0.000011   return b

FUNCTION  vundle#rc()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle.vim:63
Called 1 time
Total time:   0.000291
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000002   if a:0 > 0
                                let g:vundle#bundle_dir = expand(a:1, 1)
    1              0.000001   endif
    1   0.000284   0.000061   call vundle#config#init()

FUNCTION  indent_guides#exclude_filetype()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:279
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000020   for ft in split(&ft, '\.')
    1              0.000004     if index(g:indent_guides_exclude_filetypes, ft) > -1
                                  return 1
    1              0.000001     end
    2              0.000002   endfor
    1              0.000001   return 0

FUNCTION  <SNR>9_check_bundle_name()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:93
Called 8 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    8              0.000024   if has_key(s:bundle_names, a:bundle.name)
                                echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
                                return 0
    8              0.000074   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'
                                echoerr 'Invalid plugin name: ' . a:bundle.name
                                return 0
    8              0.000005   endif
    8              0.000026   let s:bundle_names[a:bundle.name] = a:bundle.name_spec
    8              0.000008   return 1

FUNCTION  youcompleteme#EnableCursorMovedAutocommands()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:183
Called 1 time
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
    1              0.000005   augroup ycmcompletemecursormove
    1              0.000201     autocmd!
    1              0.000010     autocmd CursorMoved * call s:OnCursorMovedNormalMode()
    1              0.000006     autocmd TextChanged * call s:OnTextChangedNormalMode()
    1              0.000005     autocmd TextChangedI * call s:OnTextChangedInsertMode( v:false )
    1              0.000002     if s:completion_api == s:COMPLETION_TEXTCHANGEDP
    1              0.000006       autocmd TextChangedP * call s:OnTextChangedInsertMode( v:true )
    1              0.000001     endif
    1              0.000006     autocmd InsertCharPre * call s:OnInsertChar()
    1              0.000001   augroup END

FUNCTION  <SNR>39_SetUpCpoptions()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:479
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
                              " Without this flag in cpoptions, critical YCM mappings do not work. There's
                              " no way to not have this and have YCM working, so force the flag.
    1              0.000015   set cpoptions+=B
                            
                              " This prevents the display of "Pattern not found" & similar messages during
                              " completion.
    1              0.000007   set shortmess+=c

FUNCTION  <SNR>13_IndentGuidesEnable()
    Defined: ~/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim:19
Called 1 time
Total time:   0.002031
 Self time:   0.000007

count  total (s)   self (s)
    1   0.002031   0.000007   call indent_guides#enable()

FUNCTION  vundle#config#bundle()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:8
Called 8 times
Total time:   0.001536
 Self time:   0.000248

count  total (s)   self (s)
    8   0.001145   0.000055   let bundle = vundle#config#init_bundle(a:arg, a:000)
    8   0.000250   0.000052   if !s:check_bundle_name(bundle)
                                return
    8              0.000005   endif
    8              0.000025   if exists('g:vundle#lazy_load') && g:vundle#lazy_load
    8              0.000024     call add(g:vundle#bundles, bundle)
                              else
                                call s:rtp_rm_a()
                                call add(g:vundle#bundles, bundle)
                                call s:rtp_add_a()
                                call s:rtp_add_defaults()
    8              0.000003   endif
    8              0.000010   return bundle

FUNCTION  indent_guides#define_default_highlights()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:168
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   hi default clear IndentGuidesOdd
    1              0.000001   hi default clear IndentGuidesEven

FUNCTION  vundle#end()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle.vim:78
Called 1 time
Total time:   0.000210
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002   unlet g:vundle#lazy_load
    1   0.000208   0.000006   call vundle#config#activate_bundles()

FUNCTION  <SNR>39_DisableOnLargeFile()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:414
Called 5 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    5              0.000045   if exists( 'b:ycm_largefile' )
    4              0.000018     return b:ycm_largefile
    1              0.000001   endif
                            
    1              0.000002   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
    1              0.000008   let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
    1              0.000001   if b:ycm_largefile
                                py3 vimsupport.PostVimMessage( 'YouCompleteMe is disabled in this buffer;' + ' the file exceeded the max size (see YCM options).' )
    1              0.000001   endif
    1              0.000001   return b:ycm_largefile

FUNCTION  <SNR>39_TurnOffSyntasticForCFamily()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:405
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003   let g:syntastic_cpp_checkers = []
    1              0.000002   let g:syntastic_c_checkers = []
    1              0.000003   let g:syntastic_objc_checkers = []
    1              0.000003   let g:syntastic_objcpp_checkers = []
    1              0.000003   let g:syntastic_cuda_checkers = []

FUNCTION  <SNR>11_LoadIndent()
    Defined: /usr/local/share/vim/vim82/indent.vim:13
Called 1 time
Total time:   0.000238
 Self time:   0.000151

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000000     endif
    1              0.000004     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000005       for name in split(s, '\.')
    1   0.000207   0.000120 	exe 'runtime! indent/' . name . '.vim'
    2              0.000000       endfor
    1              0.000001     endif

FUNCTION  <SNR>12_restore_cpo()
    Defined: ~/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim:22
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000006   let &cpo = s:save_cpo
    1              0.000002   unlet s:save_cpo

FUNCTION  <SNR>24_Highlight_Matching_Pair()
    Defined: /usr/local/share/vim/vim82/plugin/matchparen.vim:39
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
                              " Remove any previous match.
    1              0.000003   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    1              0.000000   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    1              0.000003   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    1              0.000000   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    1              0.000002   let c_lnum = line('.')
    1              0.000002   let c_col = col('.')
    1              0.000001   let before = 0
                            
    1              0.000002   let text = getline(c_lnum)
    1              0.000012   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    1              0.000002   if empty(matches)
                                let [c_before, c] = ['', '']
    1              0.000000   else
    1              0.000003     let [c_before, c] = matches[1:2]
    1              0.000001   endif
    1              0.000010   let plist = split(&matchpairs, '.\zs[:,]')
    1              0.000002   let i = index(plist, c)
    1              0.000000   if i < 0
                                " not found, in Insert mode try character before the cursor
    1              0.000002     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    1              0.000001     endif
    1              0.000001     if i < 0
                                  " not found, nothing to do
    1              0.000001       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  vundle#begin()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle.vim:72
Called 1 time
Total time:   0.000301
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   let g:vundle#lazy_load = 1
    1   0.000298   0.000007   call call('vundle#rc', a:000)

FUNCTION  <SNR>19_BuildFilenameLbl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:260
Called 2 times
Total time:   0.000088
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000002     let l:buf = bufname()
    2   0.000058   0.000012     let l:middleText = "%#FlnLbl#" . s:GetFilename(l:buf)  . " "
    2              0.000006     if (mode() ==? "i" || mode() ==? "r") 
                                    let l:funcProto = Tlist_Get_Tag_Prototype_By_Line()
                            
                                    if (len(l:funcProto))
                                        " Show function name instead in insert mode
                                        let l:middleText = "%#FuncLbl#" . s:tagNameSym .  " " . s:RightTruncate(l:funcProto,  (winwidth(0) - ((s:gitSts[l:buf]["GitAvail"] == 1)? 69 : 45)))
                                    endif
                            
    2              0.000000     endif
    2              0.000004     return " %<%(" . l:middleText . "%)"

FUNCTION  <SNR>9_rtp_rm_a()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:185
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000008   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')
    1              0.000003   let prepends = join(paths, ',')
    1              0.000003   let appends = join(paths, '/after,').'/after'
    1              0.000009   exec 'set rtp-='.fnameescape(prepends)
    1              0.000007   exec 'set rtp-='.fnameescape(appends)

FUNCTION  indent_guides#clear_matches()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:75
Called 3 times
Total time:   0.000088
 Self time:   0.000069

count  total (s)   self (s)
    3   0.000040   0.000021   call indent_guides#init_matches()
    3              0.000007   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
    3              0.000001   endif

FUNCTION  <SNR>19_BuildModeLbl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:221
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000006     let l:currentMode = mode()
    2              0.000002     let l:modeLbl = ""
                            
    2              0.000004     if (l:currentMode ==? 'n')
    2              0.000007         let l:modeLbl .= "%#NLblSepClk#". s:lASym   . "%#NLbl# NORMAL %#NLblSepFln#"    . s:rASym
                            
                                elseif (l:currentMode ==? 'v')
                                    let l:modeLbl .= "%#VLblSepClk#" . s:lASym  . "%#VLbl# VISUAL %#VLblSepFln#"    . s:rASym
                            
                                elseif (l:currentMode ==? "\<C-V>")
                                    let l:modeLbl .= "%#VLblSepClk#" . s:lASym  . "%#VLbl# V·BLOCK %#VLblSepFln#"   . s:rASym
                            
                                elseif (l:currentMode ==? 'r')
                                    let l:modeLbl .= "%#RLblSepClk#" . s:lASym  . "%#RLbl# REPLACE %#RLblSepFln#"   . s:rASym
                            
                                elseif (l:currentMode ==? 'i')
                                    let l:modeLbl .= "%#ILblSepClk#" . s:lASym  . "%#ILbl# INSERT %#ILblSepFln#"    . s:rASym
                            
                                elseif (l:currentMode ==? 's' || l:currentMode == "\<C-S>")
                                    let l:modeLbl .= "%#SLblSepClk#" . s:lASym  . "%#SLbl# SELECT %#SLblSepFln#"    . s:rASym
                            
                                else 
                                    let l:modeLbl .= "%#OLblSepClk#" . s:lASym . "%#OLBL# OTHER %#OLblSepFln#" . s:rASym
                            
    2              0.000000     endif
                            
    2              0.000003     return l:modeLbl

FUNCTION  <SNR>39_SetUpBackwardsCompatibility()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:388
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000004   let complete_in_comments_and_strings = get( g:, 'ycm_complete_in_comments_and_strings', 0 )
                            
    1              0.000002   if complete_in_comments_and_strings
                                let g:ycm_complete_in_strings = 1
                                let g:ycm_complete_in_comments = 1
    1              0.000001   endif
                            
                              " ycm_filetypes_to_completely_ignore is the old name for fileype_blacklist
    1              0.000002   if has_key( g:, 'ycm_filetypes_to_completely_ignore' )
                                let g:filetype_blacklist =  g:ycm_filetypes_to_completely_ignore
    1              0.000001   endif

FUNCTION  indent_guides#init_script_vars()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:184
Called 1 time
Total time:   0.000134
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000002   if &l:shiftwidth > 0 && &l:expandtab
    1              0.000002     let s:indent_size = &l:shiftwidth
                              else
                                let s:indent_size = &l:tabstop
    1              0.000000   endif
    1   0.000016   0.000008   let s:guide_size  = indent_guides#calculate_guide_size()
    1   0.000051   0.000019   let s:hi_normal   = indent_guides#capture_highlight('Normal')
                            
                              " remove 'font=<value>' from the s:hi_normal string (only seems to happen on Vim startup in Windows)
    1              0.000015   let s:hi_normal = substitute(s:hi_normal, ' font=[A-Za-z0-9:]\+', "", "")
                            
                              " shortcuts to the global variables - this makes the code easier to read
    1              0.000002   let s:debug             = g:indent_guides_debug
    1              0.000002   let s:indent_levels     = g:indent_guides_indent_levels
    1              0.000003   let s:auto_colors       = g:indent_guides_auto_colors
    1              0.000003   let s:color_hex_pat     = g:indent_guides_color_hex_pattern
    1              0.000003   let s:color_hex_bg_pat  = g:indent_guides_color_hex_guibg_pattern
    1              0.000002   let s:color_name_bg_pat = g:indent_guides_color_name_guibg_pattern
    1              0.000003   let s:start_level       = g:indent_guides_start_level
                            
                              " str2float not available in vim versions <= 7.1
    1              0.000003   if has('float')
    1              0.000006     let s:change_percent = g:indent_guides_color_change_percent / str2float('100.0')
                              else
                                let s:change_percent = g:indent_guides_color_change_percent / 100.0
    1              0.000000   endif
                            
    1              0.000001   if s:debug
                                echo 's:indent_size = '       . s:indent_size
                                echo 's:guide_size = '        . s:guide_size
                                echo 's:hi_normal = '         . s:hi_normal
                                echo 's:indent_levels = '     . s:indent_levels
                                echo 's:auto_colors = '       . s:auto_colors
                                echo 's:change_percent = '    . string(s:change_percent)
                                echo 's:color_hex_pat = '     . s:color_hex_pat
                                echo 's:color_hex_bg_pat = '  . s:color_hex_bg_pat
                                echo 's:color_name_bg_pat = ' . s:color_name_bg_pat
                                echo 's:start_level = '       . s:start_level
    1              0.000001   endif

FUNCTION  <SNR>39_HasAnyKey()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:429
Called 5 times
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
   10              0.000051   for key in a:keys
    5              0.000041     if has_key( a:dict, key )
                                  return 1
    5              0.000009     endif
   10              0.000027   endfor
    5              0.000015   return 0

FUNCTION  <SNR>19_GetFilename()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:48
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000005     let l:gitRootDir = s:gitSts[a:buf]["RootDir"]
    2              0.000018     let l:flname = expand("%:p")
                            
    2              0.000004     if s:gitSts[a:buf]["GitAvail"] == 1
                                    return fnamemodify(l:gitRootDir, ":t") . substitute(l:flname, l:gitRootDir, "", "")
    2              0.000000     endif
                                
    2              0.000004     if stridx(l:flname, "__Tag_List__") != -1
                                    return "__Tag_List__"
    2              0.000002     endif
    2              0.000002     return l:flname

FUNCTION  <SNR>39_AllowedToCompleteInCurrentBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:465
Called 4 times
Total time:   0.001029
 Self time:   0.000116

count  total (s)   self (s)
    4   0.001023   0.000110   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>39_AllowedToCompleteInBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:438
Called 5 times
Total time:   0.001185
 Self time:   0.000869

count  total (s)   self (s)
    5              0.000096   let buftype = getbufvar( a:buffer, '&buftype' )
                            
    5              0.000054   if has_key( s:buftype_blacklist, buftype )
                                return 0
    5              0.000018   endif
                            
    5              0.000043   let filetype = getbufvar( a:buffer, '&filetype' )
                            
    5   0.000205   0.000112   if empty( filetype ) || s:DisableOnLargeFile( a:buffer )
                                return 0
    5              0.000008   endif
                            
    5              0.000138   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( filetype, '\.' ) )
    5   0.000415   0.000192   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !s:HasAnyKey( g:ycm_filetype_blacklist, split( filetype, '\.' ) )
                            
    5              0.000030   let allowed = whitelist_allows && blacklist_allows
    5              0.000013   if allowed
    5              0.000061     let s:previous_allowed_buffer_number = bufnr( a:buffer )
    5              0.000008   endif
    5              0.000016   return allowed

FUNCTION  <SNR>39_StartMessagePoll()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:88
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000007   if s:pollers.receive_messages.id < 0
    1              0.000032     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    1              0.000002   endif

FUNCTION  <SNR>16_motion_map_helper()
    Defined: ~/.vim/bundle/vim-easymotion/plugin/EasyMotion.vim:63
Called 6 times
Total time:   0.003879
 Self time:   0.003879

count  total (s)   self (s)
   90              0.000120     for [name, dict] in items(a:motions)
   84              0.000071         let mapargs = []
   84              0.000073         let xmapargs = []
   84              0.000167         if dict.fnc ==# 'S' || dict.fnc ==# 'SL' || dict.fnc ==# 'T' || dict.fnc ==# 'TL'
   42              0.000066             let mapargs  += [dict.cnt, 0, dict.direction]
   42              0.000065             let xmapargs += [dict.cnt, 1, dict.direction]
   42              0.000037         elseif dict.fnc ==# 'Search'
    5              0.000006             let mapargs  += [0, dict.direction, dict.respect_direction]
    5              0.000008             let xmapargs += [1, dict.direction, dict.respect_direction]
   37              0.000015         else
   37              0.000055             let mapargs  += [0, dict.direction]
   37              0.000048             let xmapargs += [1, dict.direction]
   84              0.000037         endif
                            
   84              0.001229         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#' . dict.fnc . '('. join(mapargs, ',') . ')<CR>'
   84              0.001170         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#' . dict.fnc . '('. join(xmapargs, ',') . ')<CR>'
                                " Example:
                                " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
                                " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
   90              0.000052     endfor

FUNCTION  <SNR>39_PollServerReady()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:662
Called 2 times
Total time:   0.145520
 Self time:   0.127410

count  total (s)   self (s)
    2              0.000398   if !py3eval( 'ycm_state.IsServerAlive()' )
                                py3 ycm_state.NotifyUserIfServerCrashed()
                                " Server crashed. Don't poll it again.
                                return
    2              0.000005   endif
                            
    2              0.126834   if !py3eval( 'ycm_state.CheckIfServerIsReady()' )
    1              0.000021     let s:pollers.server_ready.id = timer_start( s:pollers.server_ready.wait_milliseconds, function( 's:PollServerReady' ) )
    1              0.000002     return
    1              0.000005   endif
                            
    1   0.018174   0.000064   call s:OnFileTypeSet()

FUNCTION  indent_guides#disable()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:67
Called 2 times
Total time:   0.000065
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000004   let g:indent_guides_autocmds_enabled = 0
    2   0.000061   0.000009   call indent_guides#clear_matches()

FUNCTION  <SNR>39_StopPoller()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:524
Called 7 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    7              0.000074   call timer_stop( a:poller.id )
    7              0.000063   let a:poller.id = -1

FUNCTION  youcompleteme#Enable()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:129
Called 1 time
Total time:   0.097286
 Self time:   0.000321

count  total (s)   self (s)
    1   0.000021   0.000007   call s:SetUpBackwardsCompatibility()
                            
    1   0.096001   0.000014   if !s:SetUpPython()
                                return
    1              0.000001   endif
                            
    1   0.000747   0.000026   call s:SetUpOptions()
                            
    1   0.000251   0.000008   call youcompleteme#EnableCursorMovedAutocommands()
    1              0.000001   augroup youcompleteme
    1              0.000077     autocmd!
                                " Note that these events will NOT trigger for the file vim is started with;
                                " so if you do "vim foo.cc", these events will not trigger when that buffer
                                " is read. This is because youcompleteme#Enable() is called on VimEnter and
                                " that happens *after* FileType has already triggered for the initial file.
                                " We don't parse the buffer on the BufRead event since it would only be
                                " useful if the buffer filetype is set (we ignore the buffer if there is no
                                " filetype) and if so, the FileType event has triggered before and thus the
                                " buffer is already parsed.
    1              0.000008     autocmd BufWritePost,FileWritePost * call s:OnFileSave()
    1              0.000005     autocmd FileType * call s:OnFileTypeSet()
    1              0.000007     autocmd BufEnter,CmdwinEnter * call s:OnBufferEnter()
    1              0.000004     autocmd BufUnload * call s:OnBufferUnload()
    1              0.000005     autocmd InsertLeave * call s:OnInsertLeave()
    1              0.000005     autocmd VimLeave * call s:OnVimLeave()
    1              0.000005     autocmd CompleteDone * call s:OnCompleteDone()
    1              0.000003     if exists( '##CompleteChanged' )
    1              0.000004       autocmd CompleteChanged * call s:OnCompleteChanged()
    1              0.000001     endif
    1              0.000006     autocmd BufEnter,WinEnter * call s:UpdateMatches()
    1              0.000001   augroup END
                            
                              " The FileType event is not triggered for the first loaded file. We wait until
                              " the server is ready to manually run the s:OnFileTypeSet function.
    1              0.000012   let s:pollers.server_ready.id = timer_start( s:pollers.server_ready.wait_milliseconds, function( 's:PollServerReady' ) )
                            
    1              0.000075   let s:default_completion = py3eval( 'vimsupport.NO_COMPLETIONS' )
    1              0.000003   let s:completion = s:default_completion
                            
    1              0.000005   if exists( '*prop_type_add' ) && exists( '*prop_type_delete' )
    1              0.000011     hi default YCMInverse term=reverse cterm=reverse gui=reverse
    1              0.000003     call prop_type_delete( 'YCM-signature-help-current-argument' )
    1              0.000009     call prop_type_add( 'YCM-signature-help-current-argument', {   'highlight': 'YCMInverse',   'combine':   1,   'priority':  50, } )
    1              0.000000   endif

FUNCTION  <SNR>39_OnVimLeave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:530
Called 1 time
Total time:   0.015900
 Self time:   0.015835

count  total (s)   self (s)
                              " Workaround a NeoVim issue - not shutting down timers correctly
                              " https://github.com/neovim/neovim/issues/6840
    6              0.000037   for poller in values( s:pollers )
    5   0.000143   0.000078     call s:StopPoller( poller )
    6              0.000016   endfor
    1              0.015687   py3 ycm_state.OnVimLeave()

FUNCTION  indent_guides#highlight_colors()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:94
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000001   if s:auto_colors
                                if has('gui_running') || has('nvim')
                                  call indent_guides#gui_highlight_colors()
                                else
                                  call indent_guides#basic_highlight_colors()
                                endif
    1              0.000000   endif

FUNCTION  <SNR>13_InitVariable()
    Defined: ~/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim:36
Called 11 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
   11              0.000023   if !exists(a:var)
    7              0.000017     if type(a:value) == type("")
    1              0.000003       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
    6              0.000003     else
    6              0.000022       exec 'let ' . a:var . ' = ' .  a:value
    7              0.000002     endif
   11              0.000005   endif

FUNCTION  <SNR>10_LoadFTPlugin()
    Defined: /usr/local/share/vim/vim82/ftplugin.vim:14
Called 1 time
Total time:   0.000983
 Self time:   0.000755

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000004     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000010       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000005       for name in split(s, '\.')
    1   0.000941   0.000713 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  <SNR>39_SetCompleteFunc()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:516
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000007   if s:completion_api == s:COMPLETION_COMPLETEFUNC
                                let &completefunc = 'youcompleteme#CompleteFunc'
    1              0.000002   endif
    1              0.000006   let b:ycm_completing = 1

FUNCTION  <SNR>39_SetUpCommands()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1175
Called 1 time
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
    1              0.000014   command! YcmRestartServer call s:RestartServer()
    1              0.000006   command! YcmDebugInfo call s:DebugInfo()
    1              0.000015   command! -nargs=* -complete=custom,youcompleteme#LogsComplete -count=0 YcmToggleLogs call s:ToggleLogs( <f-count>, <f-mods>, <f-args>)
    1              0.000087   if py3eval( 'vimsupport.VimVersionAtLeast( "7.4.1898" )' )
    1              0.000053     command! -nargs=* -complete=custom,youcompleteme#SubCommandsComplete -range YcmCompleter call s:CompleterCommand(<q-mods>,                                      <count>,                                      <line1>,                                      <line2>,                                      <f-args>)
                              else
                                command! -nargs=* -complete=custom,youcompleteme#SubCommandsComplete -range YcmCompleter call s:CompleterCommand('',                                      <count>,                                      <line1>,                                      <line2>,                                      <f-args>)
    1              0.000001   endif
    1              0.000007   command! YcmDiags call s:ShowDiagnostics()
    1              0.000007   command! YcmShowDetailedDiagnostic call s:ShowDetailedDiagnostic()
    1              0.000008   command! YcmForceCompileAndDiagnostics call s:ForceCompileAndDiagnostics()

FUNCTION  <SNR>35_run_syntax_fold()
    Defined: /usr/local/share/vim/vim82/syntax/ruby.vim:58
Called 157 times
Total time:   0.010296
 Self time:   0.009200

count  total (s)   self (s)
  157              0.005050   let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
  157   0.002492   0.001396   if call('s:foldable', split(groups))
  157              0.000259     let cmd .= ' fold'
  157              0.000061   endif
  157              0.002326   exe cmd

FUNCTION  <SNR>25_VimEnter()
    Defined: /usr/local/share/vim/vim82/plugin/netrwPlugin.vim:152
Called 1 time
Total time:   0.000064
 Self time:   0.000033

count  total (s)   self (s)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
    1              0.000002   let curwin       = winnr()
    1              0.000002   let s:vimentered = 1
    1   0.000054   0.000023   windo call s:LocalBrowse(expand("%:p"))
    1              0.000005   exe curwin."wincmd w"
                            "  call Dret("s:VimEnter")

FUNCTION  <SNR>9_rtp_add_defaults()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:167
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000003   let current = &rtp
    1              0.000004   set rtp&vim
    1              0.000002   let default = &rtp
    1              0.000003   let &rtp = current
    1              0.000007   let default_rtp_items = split(default, ',')
    1              0.000002   if !empty(default_rtp_items)
    1              0.000007     let first_item = fnameescape(default_rtp_items[0])
    1              0.000009     exec 'set rtp-=' . first_item
    1              0.000007     exec 'set rtp^=' . first_item
    1              0.000001   endif

FUNCTION  <SNR>39_OnFileReadyToParse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:680
Called 1 time
Total time:   0.008039
 Self time:   0.004442

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    1              0.000017   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    1              0.000009   if force_parsing || py3eval( "ycm_state.NeedsReparse()" )
                                " We switched buffers or somethuing, so claer.
                                " FIXME: sig hekp should be buffer local?
    1   0.003595   0.000035     call s:ClearSignatureHelp()
    1              0.004250     py3 ycm_state.OnFileReadyToParse()
                            
    1   0.000096   0.000059     call s:StopPoller( s:pollers.file_parse_response )
    1              0.000039     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    1              0.000011   endif

FUNCTION  <SNR>9_parse_name()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:138
Called 8 times
Total time:   0.000473
 Self time:   0.000473

count  total (s)   self (s)
    8              0.000015   let arg = a:arg
    8              0.000035   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
                            
    8              0.000111   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
    8              0.000061     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
    8              0.000030     if uri !~? '\.git$'
    8              0.000016       let uri .= '.git'
    8              0.000007     endif
    8              0.000080     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
                              elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
                                let uri = arg
                                let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
                              else
                                let name = arg
                                let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
    8              0.000005   endif
    8              0.000032   return {'name': name, 'uri': uri, 'name_spec': arg }

FUNCTION  <SNR>9_expand_path()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:237
Called 8 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    8              0.000080   return simplify(expand(a:path, 1))

FUNCTION  <SNR>39_SetUpPython()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:212
Called 1 time
Total time:   0.095987
 Self time:   0.095987

count  total (s)   self (s)
    1              0.000001   py3 << EOF
                            import os.path as p
                            import sys
                            import traceback
                            import vim
                            
                            root_folder = p.normpath( p.join( vim.eval( 's:script_folder_path' ), '..' ) )
                            third_party_folder = p.join( root_folder, 'third_party' )
                            
                            # Add dependencies to Python path.
                            dependencies = [ p.join( root_folder, 'python' ),
                                             p.join( third_party_folder, 'requests-futures' ),
                                             p.join( third_party_folder, 'ycmd' ),
                                             p.join( third_party_folder, 'requests_deps', 'idna' ),
                                             p.join( third_party_folder, 'requests_deps', 'chardet' ),
                                             p.join( third_party_folder,
                                                     'requests_deps',
                                                     'urllib3',
                                                     'src' ),
                                             p.join( third_party_folder, 'requests_deps', 'certifi' ),
                                             p.join( third_party_folder, 'requests_deps', 'requests' ) ]
                            
                            sys.path[ 0:0 ] = dependencies
                            
                            # We enclose this code in a try/except block to avoid backtraces in Vim.
                            try:
                              # Import the modules used in this file.
                              from ycm import base, vimsupport, youcompleteme
                            
                              if 'ycm_state' in globals():
                                # If re-initializing, pretend that we shut down
                                ycm_state.OnVimLeave()
                                del ycm_state
                            
                              ycm_state = youcompleteme.YouCompleteMe()
                            except Exception as error:
                              # We don't use PostVimMessage or EchoText from the vimsupport module because
                              # importing this module may fail.
                              vim.command( 'redraw | echohl WarningMsg' )
                              for line in traceback.format_exc().splitlines():
                                vim.command( "echom '{0}'".format( line.replace( "'", "''" ) ) )
                            
                              vim.command( "echo 'YouCompleteMe unavailable: {0}'"
                                           .format( str( error ).replace( "'", "''" ) ) )
                              vim.command( 'echohl None' )
                              vim.command( 'return 0' )
                            else:
                              vim.command( 'return 1' )
                            EOF

FUNCTION  indent_guides#calculate_guide_size()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:232
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002   let l:guide_size = g:indent_guides_guide_size
                            
    1              0.000002   if l:guide_size == 0 || l:guide_size > s:indent_size
                                let l:guide_size = s:indent_size
    1              0.000000   endif
                            
    1              0.000001   return l:guide_size

FUNCTION  <SNR>39_OnCursorMovedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:788
Called 1 time
Total time:   0.000288
 Self time:   0.000204

count  total (s)   self (s)
    1   0.000090   0.000006   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000001   endif
                            
    1              0.000195   py3 ycm_state.OnCursorMoved()

FUNCTION  <SNR>39_SetUpSyntaxHighlighting()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:366
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                              " We try to ensure backwards compatibility with Syntastic if the user has
                              " already defined styling for Syntastic highlight groups.
                            
    1              0.000005   if !hlexists( 'YcmErrorSection' )
                                if hlexists( 'SyntasticError' )
                                  highlight link YcmErrorSection SyntasticError
                                else
                                  highlight link YcmErrorSection SpellBad
                                endif
    1              0.000000   endif
                            
    1              0.000004   if !hlexists( 'YcmWarningSection' )
                                if hlexists( 'SyntasticWarning' )
                                  highlight link YcmWarningSection SyntasticWarning
                                else
                                  highlight link YcmWarningSection SpellCap
                                endif
    1              0.000000   endif

FUNCTION  <SNR>9_parse_options()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:117
Called 8 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                              " TODO: improve this
    8              0.000031   if len(a:opts) != 1 | return {} | endif
                            
                              if type(a:opts[0]) == type({})
                                return a:opts[0]
                              else
                                return {'rev': a:opts[0]}
                              endif

FUNCTION  indent_guides#enable()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:33
Called 1 time
Total time:   0.002024
 Self time:   0.001298

count  total (s)   self (s)
    1              0.000003   let g:indent_guides_autocmds_enabled = 1
                            
    1   0.000040   0.000007   if &diff || indent_guides#exclude_filetype()
                                call indent_guides#clear_matches()
                                return
    1              0.000001   end
                            
    1   0.000140   0.000006   call indent_guides#init_script_vars()
    1   0.000021   0.000009   call indent_guides#highlight_colors()
    1   0.000040   0.000004   call indent_guides#clear_matches()
                            
                              " loop through each indent level and define a highlight pattern
                              " will automagically figure out whether to use tabs or spaces
   30              0.000030   for l:level in range(s:start_level, s:indent_levels)
   29              0.000062     let l:group = 'IndentGuides' . ((l:level % 2 == 0) ? 'Even' : 'Odd')
   29              0.000069     let l:column_start = (l:level - 1) * s:indent_size + 1
                            
                                " define the higlight patterns and add to matches list
   29              0.000027     if g:indent_guides_space_guides
   29   0.000487   0.000237       let l:soft_pattern = indent_guides#indent_highlight_pattern(g:indent_guides_soft_pattern, l:column_start, s:guide_size)
   29              0.000236       call add(w:indent_guides_matches, matchadd(l:group, l:soft_pattern))
   29              0.000020     end
   29              0.000027     if g:indent_guides_tab_guides
   29   0.000488   0.000227       let l:hard_pattern = indent_guides#indent_highlight_pattern('\t', l:column_start, s:indent_size)
   29              0.000236       call add(w:indent_guides_matches, matchadd(l:group, l:hard_pattern))
   29              0.000014     end
   30              0.000025   endfor

FUNCTION  indent_guides#init_matches()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:176
Called 3 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    3              0.000015   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  <SNR>19_BuildFlags()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:278
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000002     let l:flags = ""
    2              0.000003     if(&modified)
                                    let l:flags .= "%#MFlagSepFln#" . s:lASym . "%#MFlag# "
    2              0.000000     endif
                                
    2              0.000002     if(&readonly || &modifiable==0)
                                    if(&modified)
                                        " M & RO
                                        let l:flags .= "%#RFlagSepMod#" . s:lASym . "%#RFlag# " 
                                    else
                                        " RO
                                        let l:flags .= "%#RFlagSepFln#" . s:lASym . "%#RFlag# " 
                                    endif
                                    let l:flags .= "%#InfBSepRFlag#"
    2              0.000000     else
    2              0.000002         if(&modified)
                                        " M 
                                        let l:flags .= "%#InfBSepMFlag#"
    2              0.000002         else
                                        "None
    2              0.000003             let l:flags .= "%#InfBSepFln#"
    2              0.000001         endif
    2              0.000001     endif
    2              0.000002     return l:flags

FUNCTION  <SNR>9_rtpath()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:250
Called 8 times
Total time:   0.000199
 Self time:   0.000060

count  total (s)   self (s)
    8   0.000195   0.000056   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()

FUNCTION  <SNR>39_OnFileTypeSet()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:598
Called 1 time
Total time:   0.018110
 Self time:   0.009061

count  total (s)   self (s)
                              " The contents of the command-line window are empty when the filetype is set
                              " for the first time. Users should never change its filetype so we only rely
                              " on the CmdwinEnter event for that window.
    1              0.000018   if !empty( getcmdwintype() )
                                return
    1              0.000003   endif
                            
    1   0.000427   0.000114   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000002   endif
                            
    1   0.000101   0.000022   call s:SetUpCompleteopt()
    1   0.000040   0.000020   call s:SetCompleteFunc()
    1   0.000059   0.000016   call s:StartMessagePoll()
    1   0.000583   0.000038   call s:EnableAutoHover()
                            
    1   0.008743   0.008733   py3 ycm_state.OnFileTypeSet()
    1   0.008112   0.000073   call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>17_Tlist_Window_Check_Auto_Open()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:4423
Called 1 time
Total time:   0.000087
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000001     let open_window = 0
                            
    1              0.000001     let i = 1
    1              0.000002     let buf_num = winbufnr(i)
    2              0.000003     while buf_num != -1
    1              0.000009         let filename = fnamemodify(bufname(buf_num), ':p')
    1   0.000022   0.000009         let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
    1   0.000027   0.000005         if !s:Tlist_Skip_File(filename, ft)
                                        let open_window = 1
                                        break
    1              0.000001         endif
    1              0.000002         let i = i + 1
    1              0.000002         let buf_num = winbufnr(i)
    2              0.000002     endwhile
                            
    1              0.000001     if open_window
                                    call s:Tlist_Window_Toggle()
    1              0.000000     endif

FUNCTION  indent_guides#process_autocmds()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:21
Called 2 times
Total time:   0.000083
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000004   if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
    2              0.000002   else
    2   0.000073   0.000008     call indent_guides#disable()
    2              0.000000   end

FUNCTION  vundle#config#activate_bundles()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:29
Called 1 time
Total time:   0.000202
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000149   0.000007   call s:rtp_add_a()
    1   0.000053   0.000007   call s:rtp_add_defaults()

FUNCTION  vundle#config#init()
    Defined: ~/.vim/bundle/Vundle.vim/autoload/vundle/config.vim:42
Called 1 time
Total time:   0.000055
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000006   if !exists('g:vundle#bundles') | let g:vundle#bundles = [] | endif
    1   0.000044   0.000013   call s:rtp_rm_a()
    1              0.000002   let g:vundle#bundles = []
    1              0.000002   let s:bundle_names = {}

FUNCTION  <SNR>16_default_mapping()
    Defined: ~/.vim/bundle/vim-easymotion/plugin/EasyMotion.vim:249
Called 1 time
Total time:   0.000556
 Self time:   0.000556

count  total (s)   self (s)
   18              0.000015         for motion in a:motions
                                        " Mapping {{{
   17              0.000032             if exists('g:EasyMotion_mapping_' . motion)
                                            " Backward compatible mapping [deprecated]
                                            silent exec 'map <silent> ' . eval('g:EasyMotion_mapping_' . motion) . ' <Plug>(easymotion-' . motion . ')'
   17              0.000247             elseif a:do_mapping && !hasmapto('<Plug>(easymotion-' . motion . ')') && empty(maparg('<Plug>(easymotion-prefix)' . motion, 'nov'))
                            
                                            " Do mapping
   17              0.000195                 silent exec 'map <silent> ' .'<Plug>(easymotion-prefix)' . motion . ' <Plug>(easymotion-' . motion . ')'
   17              0.000009             endif "}}}
   18              0.000008         endfor

FUNCTION  indent_guides#capture_highlight()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim:248
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000003   redir => l:output
    1              0.000015   exe "silent hi " . a:group_name
    1              0.000003   redir END
                            
    1              0.000010   let l:output = substitute(l:output, "\n", "", "")
    1              0.000001   return l:output

FUNCTION  <SNR>39_SetUpOptions()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:114
Called 1 time
Total time:   0.000721
 Self time:   0.000090

count  total (s)   self (s)
    1   0.000220   0.000012   call s:SetUpCommands()
    1   0.000039   0.000014   call s:SetUpCpoptions()
    1   0.000028   0.000008   call s:SetUpCompleteopt()
    1   0.000248   0.000030   call s:SetUpKeyMappings()
                            
    1              0.000001   if g:ycm_show_diagnostics_ui
    1   0.000022   0.000008     call s:TurnOffSyntasticForCFamily()
    1              0.000000   endif
                            
    1   0.000135   0.000007   call s:SetUpSigns()
    1   0.000026   0.000008   call s:SetUpSyntaxHighlighting()

FUNCTION  <SNR>25_LocalBrowse()
    Defined: /usr/local/share/vim/vim82/plugin/netrwPlugin.vim:102
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    2              0.000006   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000001    return
    1              0.000000   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    1              0.000001   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    1              0.000003   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    1              0.000001   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    1              0.000001   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>19_ManageWinStl()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:387
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000003     let l:bottomRightWin = winnr('$')
    2              0.000004     for n in range(1, bottomRightWin)
                            
    1              0.000002         let l:wintype = win_gettype(n)
                                    " Ignore popup & autocmd
    1              0.000002         if (l:wintype !=# 'popup' || l:wintype !=# 'autocmd' || l:wintype !=# "command")
                            
    1              0.000003             let l:winbufname = bufname(winbufnr(n))
                            
    1              0.000002             if l:winbufname ==# "__Tag_List__"
                                            " Set the taglist status line
                                            call setwinvar(n, '&statusline', "%!SetTaglistSts()")
                            
    1              0.000001             elseif (n == bottomRightWin)
                                            " Set bottom right Window with full status line for all windows
    1              0.000004                 call setwinvar(n, '&statusline', "%!SetStatusLine()")
                                        
                                        else
                                            " Otherwise status line should be straight line
                                            call setwinvar(n, '&statusline', "%#StraightLine#%{repeat('━',\ winwidth(".n."))}")
                                          
    1              0.000001             end
                            
    1              0.000000         endif
                            
    2              0.000002     endfor

FUNCTION  <SNR>17_Tlist_Skip_File()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:880
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                                " Skip buffers with no names and buffers with filetype not set
    1              0.000002     if a:filename == '' || a:ftype == ''
                                    return 1
    1              0.000001     endif
                            
                                " Skip files which are not supported by exuberant ctags
                                " First check whether default settings for this filetype are available.
                                " If it is not available, then check whether user specified settings are
                                " available. If both are not available, then don't list the tags for this
                                " filetype
    1              0.000002     let var = 's:tlist_def_' . a:ftype . '_settings'
    1              0.000003     if !exists(var)
                                    let var = 'g:tlist_' . a:ftype . '_settings'
                                    if !exists(var)
                                        return 1
                                    endif
    1              0.000001     endif
                            
                                " Skip files which are not readable or files which are not yet stored
                                " to the disk
    1              0.000005     if !filereadable(a:filename)
    1              0.000001         return 1
                                endif
                            
                                return 0

FUNCTION  <SNR>39_ShouldUseSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1029
Called 1 time
Total time:   0.003048
 Self time:   0.003048

count  total (s)   self (s)
    1              0.003046   return py3eval( 'vimsupport.VimSupportsPopupWindows()' )

FUNCTION  <SNR>19_BuildInfBar()
    Defined: ~/.vim/bundle/long-statusline/plugin/long-statusline.vim:306
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000004     let l:infBar = s:lASym . "%#InfB# "
                            
    2              0.000002     let l:buf = bufname()
    2              0.000004     if s:gitSts[l:buf]["GitAvail"] == 1
                                    let l:infBar .= s:gitBranchSym . " " . s:gitSts[l:buf]["BranchName"]
                                    let l:infBar .= "%#InfBStrick#" . s:sepASym . "  %#InfB#"
                                    let l:infBar .= s:gitInsSym . " " . s:gitSts[l:buf]["InsertNum"] . " "
                                    let l:infBar .= s:gitDelSym . " " . s:gitSts[l:buf]["DeleteNum"]
                                    let l:infBar .= "%#InfBStrick#" . s:sepASym . "  %#InfB#"
    2              0.000000     endif
                              
    2              0.000006     let l:infBar .= s:cnumSym . " %c" . "%#InfBStrick#" . s:sepASym . "  %#InfB#"
    2              0.000003     let l:infBar .= s:lnumSym . " %l"
    2              0.000004     let l:infBar .= " %#RCSepInfB#" . s:sepBSym . "  %#RC#%2P "
    2              0.000002     return l:infBar

FUNCTION  <SNR>39_SetUpCompleteopt()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:490
Called 2 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    2              0.000025   set completeopt-=menu
    2              0.000011   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    2              0.000010   set completeopt-=longest
                            
    2              0.000021   if g:ycm_add_preview_to_completeopt ==# 'popup' && exists( '*popup_open' )
                                set completeopt+=popup
    2              0.000007   elseif g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
    2              0.000002   endif

FUNCTION  <SNR>39_SetUpSigns()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:330
Called 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
                              " We try to ensure backwards compatibility with Syntastic if the user has
                              " already defined styling for Syntastic highlight groups.
                            
    1              0.000038   if !hlexists( 'YcmErrorSign' )
    1              0.000006     if hlexists( 'SyntasticErrorSign')
                                  highlight link YcmErrorSign SyntasticErrorSign
    1              0.000001     else
    1              0.000011       highlight link YcmErrorSign error
    1              0.000001     endif
    1              0.000001   endif
                            
    1              0.000005   if !hlexists( 'YcmWarningSign' )
    1              0.000005     if hlexists( 'SyntasticWarningSign')
                                  highlight link YcmWarningSign SyntasticWarningSign
    1              0.000001     else
    1              0.000007       highlight link YcmWarningSign todo
    1              0.000001     endif
    1              0.000000   endif
                            
    1              0.000005   if !hlexists( 'YcmErrorLine' )
    1              0.000009     highlight link YcmErrorLine SyntasticErrorLine
    1              0.000001   endif
                            
    1              0.000004   if !hlexists( 'YcmWarningLine' )
    1              0.000008     highlight link YcmWarningLine SyntasticWarningLine
    1              0.000000   endif
                            
    1              0.000012   exe 'sign define YcmError text=' . g:ycm_error_symbol . ' texthl=YcmErrorSign linehl=YcmErrorLine'
    1              0.000005   exe 'sign define YcmWarning text=' . g:ycm_warning_symbol . ' texthl=YcmWarningSign linehl=YcmWarningLine'
                            

FUNCTION  <SNR>39_EnableAutoHover()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:581
Called 1 time
Total time:   0.000545
 Self time:   0.000545

count  total (s)   self (s)
    1              0.000019   if g:ycm_auto_hover ==# 'CursorHold' && s:enable_hover
    1              0.000010     augroup YcmBufHover
    1              0.000485       autocmd! * <buffer>
    1              0.000019       autocmd CursorHold <buffer> call s:Hover()
    1              0.000003     augroup END
    1              0.000002   endif

FUNCTION  <SNR>39_OnBufferUnload()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:645
Called 1 time
Total time:   0.004257
 Self time:   0.003985

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
    1              0.000032   let buffer_number = str2nr( expand( '<abuf>' ) )
    1   0.000299   0.000027   if !s:AllowedToCompleteInBuffer( buffer_number )
                                return
    1              0.000002   endif
                            
    1              0.003908   py3 ycm_state.OnBufferUnload( vimsupport.GetIntValue( 'buffer_number' ) )

FUNCTION  <SNR>17_Tlist_Get_Buffer_Filetype()
    Defined: ~/.vim/bundle/taglist/plugin/taglist.vim:1066
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     let buf_ft = getbufvar(a:bnum, '&filetype')
                            
                                " Check whether 'filetype' contains multiple file types separated by '.'
                                " If it is, then use the first file type
    1              0.000002     if buf_ft =~ '\.'
                                    let buf_ft = matchstr(buf_ft, '[^.]\+')
    1              0.000001     endif
                            
    1              0.000002     if bufloaded(a:bnum)
                                    " For loaded buffers, the 'filetype' is already determined
    1              0.000001         return buf_ft
                                endif
                            
                                " For unloaded buffers, if the 'filetype' option is set, return it
                                if buf_ft != ''
                                    return buf_ft
                                endif
                            
                                " Skip non-existent buffers
                                if !bufexists(a:bnum)
                                    return ''
                                endif
                            
                                " For buffers whose filetype is not yet determined, try to determine
                                " the filetype
                                let bname = bufname(a:bnum)
                            
                                return s:Tlist_Detect_Filetype(bname)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.145520   0.127410  <SNR>39_PollServerReady()
    1   0.097286   0.000321  youcompleteme#Enable()
    1   0.095987             <SNR>39_SetUpPython()
    1   0.026431   0.000358  <SNR>3_SynSet()
    1   0.018110   0.009061  <SNR>39_OnFileTypeSet()
    1   0.015900   0.015835  <SNR>39_OnVimLeave()
  157   0.010296   0.009200  <SNR>35_run_syntax_fold()
    1   0.009414             <SNR>39_PollFileParseResponse()
    1   0.008039   0.004442  <SNR>39_OnFileReadyToParse()
    2   0.005905   0.005273  <SNR>39_ReceiveMessages()
    1   0.004257   0.003985  <SNR>39_OnBufferUnload()
    6   0.003879             <SNR>16_motion_map_helper()
    1   0.003560   0.000466  <SNR>39_ClearSignatureHelp()
    1   0.003048             <SNR>39_ShouldUseSignatureHelp()
    1   0.002031   0.000007  <SNR>13_IndentGuidesEnable()
    1   0.002024   0.001298  indent_guides#enable()
    8   0.001536   0.000248  vundle#config#bundle()
    5   0.001185   0.000869  <SNR>39_AllowedToCompleteInBuffer()
  159   0.001109             <SNR>35_foldable()
    8   0.001090   0.000380  vundle#config#init_bundle()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.145520   0.127410  <SNR>39_PollServerReady()
    1              0.095987  <SNR>39_SetUpPython()
    1   0.015900   0.015835  <SNR>39_OnVimLeave()
    1              0.009414  <SNR>39_PollFileParseResponse()
  157   0.010296   0.009200  <SNR>35_run_syntax_fold()
    1   0.018110   0.009061  <SNR>39_OnFileTypeSet()
    2   0.005905   0.005273  <SNR>39_ReceiveMessages()
    1   0.008039   0.004442  <SNR>39_OnFileReadyToParse()
    1   0.004257   0.003985  <SNR>39_OnBufferUnload()
    6              0.003879  <SNR>16_motion_map_helper()
    1              0.003048  <SNR>39_ShouldUseSignatureHelp()
    1   0.002024   0.001298  indent_guides#enable()
  159              0.001109  <SNR>35_foldable()
    5   0.001185   0.000869  <SNR>39_AllowedToCompleteInBuffer()
    1   0.000983   0.000755  <SNR>10_LoadFTPlugin()
    1              0.000556  <SNR>16_default_mapping()
    1              0.000545  <SNR>39_EnableAutoHover()
   58              0.000511  indent_guides#indent_highlight_pattern()
    8              0.000473  <SNR>9_parse_name()
    1   0.003560   0.000466  <SNR>39_ClearSignatureHelp()

